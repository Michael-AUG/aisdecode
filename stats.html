<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vessel Stats</title>
  <!-- Chart.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Include a date adapter for Chart.js (using date-fns) -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <!-- Socket.IO client (assumes the same server is serving it) -->
  <script src="/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    /* Vessel info container */
    #vessel-info {
      text-align: center;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    /* Vessel name styling: bold */
    #vessel-name {
      font-weight: bold;
      font-size: 24px;
    }
    /* Container for time period dropdown and reset button */
    #time-period-container {
      margin-top: 10px;
      text-align: center;
    }
    #reset-button {
      background-color: yellow;
      border: none;
      padding: 5px 10px;
      margin-left: 10px;
      cursor: pointer;
    }
    /* Chart container styles (allowing full width) */
    #chart-container, #direction-chart-container {
      width: 100%;
      margin: 0 auto 40px;
    }
    /* Compass container for side by side compasses */
    #compass-container {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin-bottom: 40px;
    }
    #compass-container > div {
      width: 45%;
    }
  </style>
</head>
<body>
  <!-- Vessel Details -->
  <div id="vessel-info">
    <div id="vessel-name">Loading vessel data...</div>
    <div id="position-accuracy-container">
      Position Accuracy: 
      <span id="position-accuracy-dot" title="Position Accuracy" style="display:inline-block; width:10px; height:10px; border-radius:50%; margin-left:5px;"></span>
    </div>
    <div id="status-container">
      Status: <span id="navigational-status">Loading...</span>
      <br>
      Last Message: <span id="last-message-time">Loading...</span>
    </div>
    <div id="time-period-container">
      Time Period: 
      <select id="time-period">
        <option>All</option>
        <option>10 minutes</option>
        <option selected>30 minutes</option>
        <option>1 hour</option>
        <option>3 hours</option>
        <option>6 hours</option>
        <option>12 hours</option>
        <option>24 hours</option>
      </select>
      <button id="reset-button">Reset</button>
    </div>
  </div>
  
  <!-- Speed on Ground Chart -->
  <div id="chart-container">
    <canvas id="sogChart"></canvas>
  </div>
  
  <!-- Compass Charts for True Heading and Course Over Ground (placed between the SOG and direction charts) -->
  <div id="compass-container">
    <div>
      <canvas id="trueHeadingCompass"></canvas>
      <div style="text-align: center; font-weight: bold;" id="trueHeadingLabel">Heading</div>
    </div>
    <div>
      <canvas id="cogCompass"></canvas>
      <div style="text-align: center; font-weight: bold;" id="cogLabel">Course</div>
    </div>
  </div>
  
  <!-- Previous Direction Chart (line chart) -->
  <div id="direction-chart-container">
    <canvas id="directionChart"></canvas>
  </div>
  
  <script>
    // Mapping for NavigationalStatus
    const navigationalStatusMapping = {
      0: "Using Engine",
      1: "At Anchor",
      2: "Not Under Command",
      3: "Restricted Manoeuvrability",
      4: "Constrained by Draft",
      5: "Moored",
      6: "Aground",
      7: "Engaged in Fishing",
      8: "Under Way Sailing",
      15: "Not Defined"
    };

    // Global arrays to store history of data points.
    let allSogData = [];
    let allDirectionData = [];

    // --- Variable to store the timestamp of the last message ---
    let lastMessageTimestamp = Date.now();
    
    // --- Helper: Update the Position Accuracy Dot ---
    function updatePositionAccuracyDot(isAccurate) {
      const dot = document.getElementById('position-accuracy-dot');
      if (dot) {
        dot.style.backgroundColor = isAccurate ? 'green' : 'red';
      }
    }

    // --- Helper: Update Navigational Status ---
    function updateNavigationalStatus(statusValue) {
      const statusText = navigationalStatusMapping[statusValue] || statusValue;
      const statusElem = document.getElementById('navigational-status');
      if (statusElem) {
        statusElem.textContent = statusText;
      }
    }
    
    // --- Helper: Filter and update chart data based on selected time period ---
    function filterChartData() {
      const selected = document.getElementById('time-period').value;
      let threshold = 0;
      if (selected !== "All") {
        let ms = 0;
        if (selected === "10 minutes") { ms = 10 * 60 * 1000; }
        else if (selected === "30 minutes") { ms = 30 * 60 * 1000; }
        else if (selected === "1 hour") { ms = 60 * 60 * 1000; }
        else if (selected === "3 hours") { ms = 3 * 60 * 60 * 1000; }
        else if (selected === "6 hours") { ms = 6 * 60 * 60 * 1000; }
        else if (selected === "12 hours") { ms = 12 * 60 * 60 * 1000; }
        else if (selected === "24 hours") { ms = 24 * 60 * 60 * 1000; }
        threshold = Date.now() - ms;
      }
      
      // Update SOG chart.
      const filteredSogData = (selected === "All") ? allSogData : allSogData.filter(item => item.timestamp >= threshold);
      sogChart.data.labels = filteredSogData.map(item => new Date(item.timestamp));
      sogChart.data.datasets[0].data = filteredSogData.map(item => item.sog);
      sogChart.update();
      
      // Update Direction chart.
      const filteredDirectionData = (selected === "All") ? allDirectionData : allDirectionData.filter(item => item.timestamp >= threshold);
      directionChart.data.labels = filteredDirectionData.map(item => new Date(item.timestamp));
      directionChart.data.datasets[0].data = filteredDirectionData.map(item => item.trueHeading);
      directionChart.data.datasets[1].data = filteredDirectionData.map(item => item.cog);
      directionChart.update();
    }
    
    // Event listener for time period changes.
    document.getElementById('time-period').addEventListener('change', filterChartData);

    // --- Helper: Format time difference ---
    function formatTimeDifference(diffMs) {
      const diffSec = Math.floor(diffMs / 1000);
      if (diffSec < 60) {
        return diffSec + " seconds";
      } else if (diffSec < 3600) {
        const diffMin = Math.floor(diffSec / 60);
        return diffMin + " minutes";
      } else {
        const diffHrs = Math.floor(diffSec / 3600);
        return diffHrs + " hours";
      }
    }

    // Update "Last Message" display every second.
    setInterval(() => {
      const now = Date.now();
      const diffMs = now - lastMessageTimestamp;
      document.getElementById('last-message-time').textContent = formatTimeDifference(diffMs);
    }, 1000);
    
    // --- 1. Parse Query Parameters ---
    function getQueryParams() {
      const params = {};
      window.location.search.substring(1).split("&").forEach(pair => {
        const [key, value] = pair.split("=");
        if (key) params[decodeURIComponent(key)] = decodeURIComponent(value || '');
      });
      return params;
    }
    const params = getQueryParams();
    const userID = params.UserID;
    if (!userID) {
      document.body.innerHTML = "<p>Error: No UserID provided in the URL.</p>";
      throw new Error("No UserID provided in the URL.");
    }
    
    // --- 2. Set Up the Speed on Ground Chart ---
    const ctxSog = document.getElementById('sogChart').getContext('2d');
    const sogData = {
      labels: [],
      datasets: [{
        label: 'Speed on Ground (kn)',
        data: [],
        fill: false,
        borderColor: 'blue',
        tension: 0.1
      }]
    };
    const sogChart = new Chart(ctxSog, {
      type: 'line',
      data: sogData,
      options: {
        responsive: true,
        animation: { duration: 0 },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'second',
              tooltipFormat: 'HH:mm:ss',
              displayFormats: { second: 'HH:mm:ss' }
            }
          },
          y: {
            title: { display: true, text: 'Speed (kn)' }
          }
        }
      }
    });
    
    function addSogDataPoint(timestamp, sogValue) {
      allSogData.push({ timestamp: timestamp, sog: sogValue });
      filterChartData();
    }
    
    // --- 3. Compass Plugin: Draw cardinal directions and red arrow ---
    const compassPlugin = {
      id: 'compassPlugin',
      afterDraw: (chart) => {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const centerX = chartArea.left + (chartArea.right - chartArea.left) / 2;
        const centerY = chartArea.top + (chartArea.bottom - chartArea.top) / 2;
        const radius = Math.min(chartArea.width, chartArea.height) / 2;
        
        // Draw outer circle.
        ctx.save();
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius - 10, 0, 2 * Math.PI);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
        
        // Draw cardinal labels.
        ctx.save();
        ctx.font = "14px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("N", centerX, centerY - radius + 20);
        ctx.fillText("E", centerX + radius - 20, centerY);
        ctx.fillText("S", centerX, centerY + radius - 20);
        ctx.fillText("W", centerX - radius + 20, centerY);
        ctx.restore();
        
        // Draw the red arrow if a currentDirection value exists.
        if (chart.currentDirection !== undefined) {
          // Use the heading value directly so that 0° points up, 90° to the right, etc.
          const angle = chart.currentDirection * Math.PI / 180;
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(0, -radius + 30);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.stroke();
          // Draw arrowhead.
          ctx.beginPath();
          ctx.moveTo(0, -radius + 30);
          ctx.lineTo(-5, -radius + 40);
          ctx.lineTo(5, -radius + 40);
          ctx.closePath();
          ctx.fillStyle = "red";
          ctx.fill();
          ctx.restore();
        }
      }
    };
    
    // --- 4. Set Up the Compass Charts ---
    // For the compasses we remove the built-in rotation so that our plugin drawing is in the expected orientation.
    const ctxTrueHeading = document.getElementById('trueHeadingCompass').getContext('2d');
    const trueHeadingCompass = new Chart(ctxTrueHeading, {
      type: 'doughnut',
      data: {
        labels: [],
        datasets: [{
          data: [1],
          backgroundColor: ['#e0e0e0'],
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        rotation: 0,
        circumference: 2 * Math.PI,
        cutout: '80%',
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          title: { display: false }
        }
      },
      plugins: [compassPlugin]
    });
    
    const ctxCog = document.getElementById('cogCompass').getContext('2d');
    const cogCompass = new Chart(ctxCog, {
      type: 'doughnut',
      data: {
        labels: [],
        datasets: [{
          data: [1],
          backgroundColor: ['#e0e0e0'],
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        rotation: 0,
        circumference: 2 * Math.PI,
        cutout: '80%',
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false },
          title: { display: false }
        }
      },
      plugins: [compassPlugin]
    });
    
    function updateCompassCharts(trueHeading, cog) {
      // Round the values to the nearest whole number.
      trueHeading = Math.round(trueHeading);
      cog = Math.round(cog);

      trueHeadingCompass.currentDirection = trueHeading;
      document.getElementById('trueHeadingLabel').textContent = "Heading: " + trueHeading + "°";
      trueHeadingCompass.update();
      
      cogCompass.currentDirection = cog;
      document.getElementById('cogLabel').textContent = "Course: " + cog + "°";
      cogCompass.update();
    }
    
    // --- 5. Set Up the Direction (Line) Chart ---
    const ctxDirection = document.getElementById('directionChart').getContext('2d');
    const directionData = {
      labels: [],
      datasets: [
        {
          label: 'True Heading (°)',
          data: [],
          fill: false,
          borderColor: 'red',
          tension: 0.1
        },
        {
          label: 'Course Over Ground (°)',
          data: [],
          fill: false,
          borderColor: 'green',
          tension: 0.1
        }
      ]
    };
    const directionChart = new Chart(ctxDirection, {
      type: 'line',
      data: directionData,
      options: {
        responsive: true,
        animation: { duration: 0 },
        scales: {
          x: {
            type: 'time',
            time: {
              unit: 'second',
              tooltipFormat: 'HH:mm:ss',
              displayFormats: { second: 'HH:mm:ss' }
            }
          },
          y: {
            min: 0,
            max: 360,
            title: { display: true, text: 'Degrees' }
          }
        }
      }
    });
    
    function addDirectionDataPoint(timestamp, trueHeading, cog) {
      allDirectionData.push({ timestamp: timestamp, trueHeading: trueHeading, cog: cog });
      filterChartData();
    }
    
    // --- 6. Load Initial State from /state.json ---
    function loadInitialState() {
      fetch('/state.json')
        .then(response => response.json())
        .then(stateData => {
          const vesselState = stateData[userID];
          if (vesselState && vesselState.Name) {
            document.getElementById('vessel-name').innerHTML = vesselState.Name + " (" + vesselState.CallSign + ")";
            updatePositionAccuracyDot(vesselState.PositionAccuracy);
            updateNavigationalStatus(vesselState.NavigationalStatus);
            // Update SOG chart.
            if (vesselState.Sog !== undefined) {
              const ts = vesselState.LastUpdated ? new Date(vesselState.LastUpdated).getTime() : Date.now();
              addSogDataPoint(ts, vesselState.Sog);
            } else {
              addSogDataPoint(Date.now(), 0);
            }
            // Update both the compass and direction charts.
            if (vesselState.TrueHeading !== undefined && vesselState.Cog !== undefined) {
              const ts = vesselState.LastUpdated ? new Date(vesselState.LastUpdated).getTime() : Date.now();
              addDirectionDataPoint(ts, vesselState.TrueHeading, vesselState.Cog);
              updateCompassCharts(vesselState.TrueHeading, vesselState.Cog);
            } else {
              addDirectionDataPoint(Date.now(), 0, 0);
              updateCompassCharts(0, 0);
            }
          } else {
            document.getElementById('vessel-name').textContent = "Vessel not found.";
            addSogDataPoint(Date.now(), 0);
            addDirectionDataPoint(Date.now(), 0, 0);
            updateCompassCharts(0, 0);
          }
        })
        .catch(err => {
          console.error("Error loading /state.json:", err);
          document.getElementById('vessel-name').textContent = "Error loading vessel data.";
          addSogDataPoint(Date.now(), 0);
          addDirectionDataPoint(Date.now(), 0, 0);
          updateCompassCharts(0, 0);
        });
    }
    
    loadInitialState();
    
    // --- 7. Connect to Socket.IO and Subscribe ---
    const socket = io();
    const channel = "ais_data/" + userID;
    socket.emit("subscribe", channel);
    
    socket.on("ais_data", (message) => {
      if (typeof message === "string") {
        try { message = JSON.parse(message); }
        catch (e) { console.error("Error parsing ais_data message:", e); return; }
      }
      if (message.type === "ais.PositionReport" && message.data) {
        if (message.data.UserID && message.data.UserID.toString() === userID.toString()) {
          const ts = message.timestamp ? new Date(message.timestamp).getTime() : Date.now();
          lastMessageTimestamp = ts;
          if (message.data.Sog !== undefined) {
            addSogDataPoint(ts, message.data.Sog);
          }
          if (message.data.TrueHeading !== undefined && message.data.Cog !== undefined) {
            addDirectionDataPoint(ts, message.data.TrueHeading, message.data.Cog);
            updateCompassCharts(message.data.TrueHeading, message.data.Cog);
          }
          if (message.data.PositionAccuracy !== undefined) {
            updatePositionAccuracyDot(message.data.PositionAccuracy);
          }
          if (message.data.NavigationalStatus !== undefined) {
            updateNavigationalStatus(message.data.NavigationalStatus);
          }
        }
      }
    });
    
    // --- 8. Reset Button: Clear all charts and refetch state ---
    document.getElementById('reset-button').addEventListener('click', () => {
      // Clear SOG data.
      allSogData = [];
      sogChart.data.labels = [];
      sogChart.data.datasets[0].data = [];
      sogChart.update();
      
      // Clear direction (line) chart data.
      allDirectionData = [];
      directionChart.data.labels = [];
      directionChart.data.datasets[0].data = [];
      directionChart.data.datasets[1].data = [];
      directionChart.update();
      
      // Reset compass charts.
      trueHeadingCompass.currentDirection = 0;
      document.getElementById('trueHeadingLabel').textContent = "True Heading";
      trueHeadingCompass.update();
      
      cogCompass.currentDirection = 0;
      document.getElementById('cogLabel').textContent = "Course Over Ground";
      cogCompass.update();
      
      // Re-fetch initial state.
      loadInitialState();
    });
    
    // --- 9. Clean-up on Unload ---
    window.addEventListener('beforeunload', () => {
      socket.emit("unsubscribe", channel);
    });
    
    // --- 10. Resize charts on window resize ---
    window.addEventListener('resize', () => {
      sogChart.resize();
      trueHeadingCompass.resize();
      cogCompass.resize();
      directionChart.resize();
    });
  </script>
</body>
</html>
