<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Metrics Dashboard</title>
  <!-- Load Socket.IO client library -->
  <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
  <!-- Load Chart.js library -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Load a date adapter for Chart.js (using date-fns in this example) -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .chart-container {
      width: 600px;
      margin-bottom: 30px;
    }
    .live-data {
      margin-bottom: 20px;
    }
    table {
      border-collapse: collapse;
      margin-bottom: 30px;
    }
    table, th, td {
      border: 1px solid #ccc;
      padding: 5px;
    }
    /* Digital Dashboard styles with black and green theme */
    .digital-dashboard {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }
    .digital-card {
      background-color: #000;
      color: limegreen;
      border-radius: 8px;
      padding: 20px;
      min-width: 180px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .digital-card h3 {
      margin: 0 0 10px;
      font-size: 16px;
      color: limegreen;
    }
    .digital-card p {
      font-size: 24px;
      margin: 0;
      font-weight: bold;
    }
    /* Styling for individual websocket room cards using the same black/green theme */
    .ws-room-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .ws-room-card {
      background-color: #000;
      color: limegreen;
      border: 1px solid limegreen;
      border-radius: 8px;
      padding: 10px;
      font-size: 14px;
      text-align: left;
    }
    /* Styling for collapsible sections */
    details {
      margin-bottom: 20px;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
    }
    details summary {
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      outline: none;
    }
  </style>
</head>
<body>
  <h1>Metrics Dashboard</h1>

  <!-- Collapsible Live Metrics Table Section (collapsed by default) -->
  <details>
    <summary>Live Metrics (Table)</summary>
    <div class="live-data">
      <div id="liveMetrics">
        <!-- Live metrics will be inserted here -->
      </div>
    </div>
  </details>

  <!-- Collapsible Digital Dashboard Section (expanded by default) -->
  <details open>
    <summary>Live Metrics (Digital Dashboard)</summary>
    <div class="live-data">
      <!-- First row: other metrics -->
      <div class="digital-dashboard">
        <!-- Digital card for serial_messages_per_sec -->
        <div class="digital-card" id="card-serial_messages_per_sec">
          <h3>Serial Msgs/sec</h3>
          <p id="val-serial_messages_per_sec">--</p>
        </div>
        <!-- Digital card for serial_messages_per_min -->
        <div class="digital-card" id="card-serial_messages_per_min">
          <h3>Serial Msgs/min</h3>
          <p id="val-serial_messages_per_min">--</p>
        </div>
        <!-- Digital card for udp_messages_per_sec -->
        <div class="digital-card" id="card-udp_messages_per_sec">
          <h3>UDP Msgs/sec</h3>
          <p id="val-udp_messages_per_sec">--</p>
        </div>
        <!-- Digital card for udp_messages_per_min -->
        <div class="digital-card" id="card-udp_messages_per_min">
          <h3>UDP Msgs/min</h3>
          <p id="val-udp_messages_per_min">--</p>
        </div>
        <!-- Digital card for uptime_seconds -->
        <div class="digital-card" id="card-uptime_seconds">
          <h3>Uptime</h3>
          <p id="val-uptime_seconds">--</p>
        </div>
        <!-- Digital card for total_messages -->
        <div class="digital-card" id="card-total_message">
          <h3>Total Messages</h3>
          <p id="val-total_messages">--</p>
        </div>
        <!-- Digital card for total_deduplications -->
        <div class="digital-card" id="card-total_deduplications">
          <h3>Total Deduplications</h3>
          <p id="val-total_deduplications">--</p>
        </div>
        <!-- Digital card for total_known_vessels -->
        <div class="digital-card" id="card-total_known_vessels">
          <h3>Total Known Vessels</h3>
          <p id="val-total_known_vessels">--</p>
        </div>
        <!-- Digital card for active_websockets -->
        <div class="digital-card" id="card-active_websockets">
          <h3>Active Websockets</h3>
          <p id="val-active_websockets">--</p>
        </div>
      </div>
      <!-- Second row: Active websocket rooms -->
      <div class="digital-dashboard">
        <div class="digital-card" id="card-active_websocket_rooms">
          <h3>Active Websocket Rooms</h3>
          <div id="val-active_websocket_rooms" class="ws-room-container">
            <!-- Individual room cards will be inserted here -->
          </div>
        </div>
      </div>
    </div>
  </details>

  <!-- Collapsible Historical Metrics Section (expanded by default) -->
  <details open>
    <summary>Historical Metrics</summary>
    <div id="charts">
      <!-- Historical charts will be inserted here -->
    </div>
  </details>

  <script>
    // Helper function to format uptime in seconds to "0d 0h 4m 10s" format.
    function formatUptime(seconds) {
      const d = Math.floor(seconds / (3600 * 24));
      const h = Math.floor((seconds % (3600 * 24)) / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return `${d}d ${h}h ${m}m ${s}s`;
    }

    // Helper function to format numbers.
    // For total_messages and total_deduplications, if the value is under 1000 show the raw value.
    // For other large numbers, abbreviate as needed.
    function formatNumber(n) {
      if (n < 1000) {
        return n.toString();
      } else if (n < 1000000) {
        let result = n / 1000;
        return (result % 1 === 0) ? result + "k" : result.toFixed(1) + "k";
      } else {
        let result = n / 1000000;
        return (result % 1 === 0) ? result + "m" : result.toFixed(1) + "m";
      }
    }

    // Connect to the websocket server.
    const socket = io();

    // Update the live metrics table.
    function updateLiveDisplay(metrics) {
      const liveDiv = document.getElementById("liveMetrics");
      let html = "<table><tr><th>Metric</th><th>Value</th></tr>";
      for (const key in metrics) {
        html += `<tr><td>${key}</td><td>${metrics[key]}</td></tr>`;
      }
      html += "</table>";
      liveDiv.innerHTML = html;
    }

    // Update the digital dashboard cards.
    function updateDigitalDashboard(metrics) {
      // Update individual cards.
      document.getElementById("val-serial_messages_per_sec").textContent =
        metrics.serial_messages_per_sec !== undefined ? metrics.serial_messages_per_sec : "--";
      document.getElementById("val-serial_messages_per_min").textContent =
        metrics.serial_messages_per_min !== undefined ? metrics.serial_messages_per_min : "--";
      document.getElementById("val-udp_messages_per_sec").textContent =
        metrics.udp_messages_per_sec !== undefined ? metrics.udp_messages_per_sec : "--";
      document.getElementById("val-udp_messages_per_min").textContent =
        metrics.udp_messages_per_min !== undefined ? metrics.udp_messages_per_min : "--";

      // Update uptime_seconds with formatted uptime.
      document.getElementById("val-uptime_seconds").textContent =
        metrics.uptime_seconds !== undefined ? formatUptime(metrics.uptime_seconds) : "--";

      // Update total_messages with raw value when under 1000.
      document.getElementById("val-total_messages").textContent =
        metrics.total_messages !== undefined ? formatNumber(metrics.total_messages) : "--";

      // Update total_deduplications with raw value when under 1000.
      document.getElementById("val-total_deduplications").textContent =
        metrics.total_deduplications !== undefined ? formatNumber(metrics.total_deduplications) : "--";

      // Update total_known_vessels.
      document.getElementById("val-total_known_vessels").textContent =
        metrics.total_known_vessels !== undefined ? metrics.total_known_vessels : "--";

      // Update active_websockets.
      document.getElementById("val-active_websockets").textContent =
        metrics.active_websockets !== undefined ? metrics.active_websockets : "--";

      // Update active_websocket_rooms display.
      const wsRoomsContainer = document.getElementById("val-active_websocket_rooms");
      wsRoomsContainer.innerHTML = "";
      if (metrics.active_websocket_rooms && typeof metrics.active_websocket_rooms === "object") {
        for (const room in metrics.active_websocket_rooms) {
          const count = metrics.active_websocket_rooms[room];
          const roomCard = document.createElement("div");
          roomCard.className = "ws-room-card";
          roomCard.textContent = `${room}: ${count} user(s)`;
          wsRoomsContainer.appendChild(roomCard);
        }
      } else {
        wsRoomsContainer.textContent = "--";
      }
    }

    // Listen for live metrics updates from the websocket.
    socket.on("metrics_update", function(data) {
      try {
        const metrics = JSON.parse(data);
        updateLiveDisplay(metrics);
        updateDigitalDashboard(metrics);
      } catch (e) {
        console.error("Error parsing live metrics:", e);
      }
    });

    socket.on("connect", function() {
      socket.emit("subscribeMetrics");
    });

    // Fetch historical metrics data from the /metrics endpoint.
    async function fetchHistoricalMetrics() {
      try {
        const response = await fetch("/metrics");
        const data = await response.json();
        return data;
      } catch (e) {
        console.error("Error fetching historical metrics:", e);
        return null;
      }
    }

    // --- Historical Charts Functions ---
    // Calculate fixed time range: from 60 minutes ago to now.
    function getFixedTimeRange() {
      const now = new Date();
      return {
        min: new Date(now.getTime() - 60 * 60 * 1000),
        max: now
      };
    }

    // Create a line chart for multiple datasets.
    function createMultiLineChart(ctx, labels, datasets, chartLabel) {
      const timeRange = getFixedTimeRange();
      return new Chart(ctx, {
        type: "line",
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          animation: { duration: 0 },
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: chartLabel
            }
          },
          scales: {
            x: {
              type: "time",
              time: {
                tooltipFormat: "PPpp",
                unit: "minute",
                stepSize: 1
              },
              min: timeRange.min,
              max: timeRange.max,
              title: {
                display: true,
                text: "Time"
              }
            },
            y: {
              title: {
                display: true,
                text: chartLabel
              }
            }
          }
        }
      });
    }

    // Create a stacked bar chart.
    function createStackedBarChart(ctx, labels, datasets, chartLabel) {
      const timeRange = getFixedTimeRange();
      return new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          animation: { duration: 0 },
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: chartLabel
            }
          },
          scales: {
            x: {
              stacked: true,
              type: "time",
              time: {
                tooltipFormat: "PPpp",
                unit: "minute",
                stepSize: 1
              },
              min: timeRange.min,
              max: timeRange.max,
              title: {
                display: true,
                text: "Time"
              }
            },
            y: {
              stacked: true,
              title: {
                display: true,
                text: "Number of Vessels"
              }
            }
          }
        }
      });
    }

    // Render historical charts based on fetched data.
    async function renderHistoricalCharts() {
      // Save the current scroll position.
      const scrollPos = window.pageYOffset;

      const historical = await fetchHistoricalMetrics();
      if (!historical || !historical.minute_averages) return;

      // We assume minute_averages is an array with up to 60 snapshots.
      const snapshots = historical.minute_averages;
      // Extract timestamps.
      const timestamps = snapshots.map(snap => new Date(snap.timestamp));

      // 1) Line chart for serial_messages_per_min and udp_messages_per_min.
      const serialMsgsMin = snapshots.map(snap => snap.serial_messages_per_min.average);
      const udpMsgsMin = snapshots.map(snap => snap.udp_messages_per_min.average);
      const chartsDiv = document.getElementById("charts");
      chartsDiv.innerHTML = ""; // Clear previous charts

      let container = document.createElement("div");
      container.className = "chart-container";
      let heading = document.createElement("h3");
      heading.textContent = "Serial & UDP Messages per Minute (Last 60 minutes)";
      container.appendChild(heading);
      let canvas1 = document.createElement("canvas");
      container.appendChild(canvas1);
      chartsDiv.appendChild(container);
      createMultiLineChart(canvas1.getContext("2d"), timestamps, [
        {
          label: "Serial Msgs/min",
          data: serialMsgsMin,
          fill: false,
          borderColor: "blue"
        },
        {
          label: "UDP Msgs/min",
          data: udpMsgsMin,
          fill: false,
          borderColor: "red"
        }
      ], "Messages per Minute");

      // 2) Stacked bar chart for vessel counts.
      const classA = snapshots.map(snap => snap.num_vessels_class_a.average);
      const classB = snapshots.map(snap => snap.num_vessels_class_b.average);
      const aton = snapshots.map(snap => snap.num_vessels_aton.average);
      const baseStation = snapshots.map(snap => snap.num_vessels_base_station.average);
      const sar = snapshots.map(snap => snap.num_vessels_sar.average);
      container = document.createElement("div");
      container.className = "chart-container";
      heading = document.createElement("h3");
      heading.textContent = "Vessel Counts (Stacked, Last 60 minutes)";
      container.appendChild(heading);
      let canvas2 = document.createElement("canvas");
      container.appendChild(canvas2);
      chartsDiv.appendChild(container);
      createStackedBarChart(canvas2.getContext("2d"), timestamps, [
        {
          label: "Class A",
          data: classA,
          backgroundColor: "rgba(54, 162, 235, 0.7)"
        },
        {
          label: "Class B",
          data: classB,
          backgroundColor: "rgba(255, 99, 132, 0.7)"
        },
        {
          label: "AtoN",
          data: aton,
          backgroundColor: "rgba(255, 206, 86, 0.7)"
        },
        {
          label: "Base Station",
          data: baseStation,
          backgroundColor: "rgba(75, 192, 192, 0.7)"
        },
        {
          label: "SAR",
          data: sar,
          backgroundColor: "rgba(153, 102, 255, 0.7)"
        }
      ], "Vessel Types");

      // 3) Line chart for active_websockets.
      const activeWebsockets = snapshots.map(snap => snap.active_websockets.average);
      container = document.createElement("div");
      container.className = "chart-container";
      heading = document.createElement("h3");
      heading.textContent = "Active Websockets (Last 60 minutes)";
      container.appendChild(heading);
      let canvas3 = document.createElement("canvas");
      container.appendChild(canvas3);
      chartsDiv.appendChild(container);
      createMultiLineChart(canvas3.getContext("2d"), timestamps, [
        {
          label: "Active Websockets",
          data: activeWebsockets,
          fill: false,
          borderColor: "green"
        }
      ], "Active Websockets");

      // Restore the original scroll position after rendering the charts.
      window.scrollTo(0, scrollPos);
    }

    // Render historical charts on page load.
    renderHistoricalCharts();
    // Re-fetch and re-render historical data every minute.
    setInterval(renderHistoricalCharts, 60 * 1000);
  </script>
</body>
</html>
