<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AIS Tracker</title>
    <!-- Leaflet CSS (from CDN, without integrity) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin="" />
    <style>
        html, body, #map {
          height: 100%;
          margin: 0;
          padding: 0;
        }
        .popup-content {
          font-family: Arial, sans-serif;
          font-size: 14px;
          line-height: 1.3;
        }
        .boat-icon {
          background: transparent;
          border: none;
          transition: transform 0.5s ease-out;
        }
        /* CSS for the enlargement animation */
        .boat-icon.enlarge {
          transform: scale(1.5);
        }
        .vessel-tooltip {
          font-family: Arial, sans-serif;
          font-size: 10px;
          font-weight: bold;
          background: rgba(255, 255, 255, 0.9);
          padding: 2px 4px;
          border: 1px solid #aaa;
          border-radius: 3px;
          cursor: pointer;
        }
        /* Style for the Clear History button */
        #clear-history {
          position: absolute;
          bottom: 25px;
          left: 10px;
          background: yellow;
          border: none;
          padding: 5px 5px;
          cursor: pointer;
          font-weight: bold;
          z-index: 1000;
        }
        /* Style for the known vessels overlay (bottom left) */
        #vessel-overlay {
          position: absolute;
          bottom: 85px;
          left: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          height: 300px;
          width: 150px;
          overflow-y: auto;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
        }
        #vessel-overlay h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the filter input box */
        #vessel-filter {
          width: 90%;
          margin: 5px auto;
          display: block;
          padding: 3px;
          font-size: 13px;
        }
        #vessel-overlay .vessel-entry {
          border-bottom: 1px solid #eee;
          padding: 4px 0;
          cursor: pointer;
        }
        #vessel-overlay .vessel-entry:last-child {
          border-bottom: none;
        }
        #vessel-overlay .vessel-name {
          font-weight: bold;
          text-decoration: underline;
        }
        #vessel-overlay .vessel-callsign {
          color: #555;
        }
        #vessel-overlay .vessel-timestamp {
          color: #888;
          font-size: 12px;
        }
        /* New Style for the vessel detail overlay (bottom right) */
        #vessel-detail {
          position: absolute;
          bottom: 80px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 5px;
          max-height: 300px;
          min-width: 200px;
          width: auto;
          overflow-y: auto;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 13px;
          line-height: 1.4;
          display: none;
          white-space: nowrap;
        }
        #vessel-detail h4 {
          margin: 5px 0;
          text-align: center;
          font-size: 14px;
        }
        /* Style for the controls overlay */
        #controls {
          position: absolute;
          top: 10px;
          right: 10px;
          background: rgba(255, 255, 255, 0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          z-index: 1000;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        #controls label {
          cursor: pointer;
          display: block;
          margin-bottom: 5px;
        }
        /* Styles for the new toggle buttons */
        .toggle-button {
          position: absolute;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
        }
        #toggle-known-overlay {
          bottom: 60px;
          left: 10px;
        }
        #toggle-detail-overlay {
          bottom: 50px;
          right: 10px;
          display: none;
        }
        /* Live Logs button styling (positioned to the left of Show/Hide Details) */
        #live-logs {
          position: absolute;
          bottom: 50px;
          right: 100px;
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;
        }
        /* Live Logs overlay styling */
        #live-logs-overlay {
          display: none;
          position: absolute;
          top: 100px;
          left: 50px;
          background: rgba(255,255,255,0.95);
          border: 1px solid #ccc;
          border-radius: 5px;
          padding: 10px;
          width: 290px;
          max-height: 400px;
          overflow-y: auto;
          z-index: 1200;
        }
        #live-logs-header {
          cursor: move;
          font-weight: bold;
          margin-bottom: 5px;
        }
        #live-logs-header button {
          float: right;
          cursor: pointer;
        }
        .log-entry {
          border-bottom: 1px solid #eee;
          padding: 5px 0;
          font-family: monospace;
          font-size: 12px;
        }
        .log-entry:last-child {
          border-bottom: none;
        }
        .log-field {
          font-weight: bold;
        }
        #stats-button {
          position: absolute;
          bottom: 50px;
          right: 180px;  /* Adjust as needed so it appears left of the "Messages" button */
          background: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 3px;
          padding: 3px 6px;
          font-family: Arial, sans-serif;
          font-size: 13px;
          cursor: pointer;
          z-index: 1100;
          display: none;  /* Hidden by default */
    }
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="latlong-display" style="
	    position: absolute;
	    top: 10px;
	    left: 50%;
	    transform: translateX(-50%);
	    background: rgba(255, 255, 255, 0.8);
	    padding: 5px 10px;
	    border-radius: 5px;
	    z-index: 1100;
	    font-family: Arial, sans-serif;
	    font-size: 14px;
	">
        0, 0
    </div>
    <div id="nm-scale" style="
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 5px;
    z-index: 1100;
    font-family: Arial, sans-serif;
    font-size: 14px;
    text-align: center;
">
        <div id="scale-bar" style="
      position: relative;
      width: 100px;
      height: 4px;
      background: black;
      margin-bottom: 2px;
  ">
            <!-- Left tick -->
            <div style="
        position: absolute;
        left: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
            <!-- Right tick -->
            <div style="
        position: absolute;
        right: 0;
        top: -4px;
        width: 2px;
        height: 12px;
        background: black;
    "></div>
        </div>
        <div id="scale-label">0 NM</div>
    </div>

    <!-- Controls Overlay -->
    <div id="controls">
        <label>
  <div id="connection-status" style="display: flex; align-items: center; margin-bottom: 5px; margin-left: 5px;">
    <span id="status-dot" style="width: 10px; height: 10px; border-radius: 50%; background: red; display: inline-block; margin-right: 5px;"></span>
    <span id="status-text">Disconnected</span>
  </div>
    <input type="checkbox" id="auto-zoom">
    Auto Zoom
  </label>
        <label>
    <input type="checkbox" id="only-focussed">
    Only Tracked
  </label>
        <label>
    <input type="checkbox" id="openseamap-overlay" checked>
    Map Overlay
  </label>
        <label>
    <input type="checkbox" id="show-paths" checked>
    Show Paths
  </label>
        <label>
    <input type="checkbox" id="stationary" checked>
    Stationary
  </label>
    </div>

    <!-- Known vessels overlay (bottom left) -->
    <div id="vessel-overlay">
        <!-- Filter input box -->
        <input type="text" id="vessel-filter" placeholder="Filter vessels...">
        <div id="vessel-count" style="text-align: left; margin-bottom: 0px;">Total: 0</div>
        <div id="overlay-content"></div>
    </div>

    <!-- Vessel detail overlay (bottom right) -->
    <div id="vessel-detail">
        <h4 id="vessel-detail-header">Vessel Details</h4>
        <div id="detail-content"></div>
    </div>

    <!-- Toggle Buttons -->
    <button id="toggle-known-overlay" class="toggle-button">Hide Vessels</button>
    <button id="toggle-detail-overlay" class="toggle-button">Hide Details</button>

    <button id="stats-button">Stats</button>
    <button id="live-logs">Messages</button>

    <button id="clear-history">Clear History</button>

    <!-- Live Logs Overlay (draggable) -->
    <div id="live-logs-overlay">
        <div id="live-logs-header">
            <span id="live-logs-title">Live Messages</span>
            <button id="close-live-logs">X</button>
        </div>
        <div id="live-logs-filters" style="padding: 2px; border-bottom: 1px solid #ccc; font-size: 12px;">
            <label style="white-space: nowrap;">
      <input type="checkbox" class="log-filter" value="ais.PositionReport" checked> Position
    </label>
            <label style="white-space: nowrap;">
      <input type="checkbox" class="log-filter" value="ais.ShipStaticData" checked> Static
    </label>
            <label style="white-space: nowrap;">
      <input type="checkbox" class="log-filter" value="ais.StandardClassBPositionReport" checked> Std. B
    </label>
            <label style="white-space: nowrap;">
      <input type="checkbox" class="log-filter" value="ais.ExtendedClassBPositionReport" checked> Ext. B
    </label>
            <input type="text" id="live-log-search" placeholder="Search logs..." style="width:100%; margin-top:5px; padding:3px; font-size:12px;">
        </div>
        <div id="live-logs-content"></div>
    </div>

    <!-- Socket.IO client (local copy) -->
    <script src="socket.io.min.js"></script>
    <!-- Leaflet JS (from CDN, without integrity) -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
    <script>
        // Detect if the device is touch capable.
        const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
        // Flag to track if the user manually hid the details overlay.
        let detailsOverlayHidden = false;

	let mids = {};
	fetch('mids.json')
	  .then(response => {
	    if (!response.ok) {
	      throw new Error(`Network error: ${response.status}`);
	    }
	    return response.json();
	  })
	  .then(data => {
	    mids = data;
	  })
	  .catch(error => {
	    console.error('Error loading mids.json:', error);
	  });

        // Global variable to store the currently focused vessel (if any).
        let focusedVessel = null;

        // Initialize the Leaflet map.
        const map = L.map('map').setView([55.0, -3.0], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // OpenSeaMap overlay layer (enabled by default).
        const openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
          attribution: 'Map data: &copy; OpenSeaMap contributors'
        }).addTo(map);

    const allowedMessageTypes = {
      "ais.PositionReport": true,
      "ais.ShipStaticData": true,
      "ais.StandardClassBPositionReport": true,
      "ais.ExtendedClassBPositionReport": true
    };

	map.on('mousemove', function(e) {
	  if (!focusedVessel) {
	    document.getElementById('latlong-display').textContent =
	      `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
	  }
	});

        // Helper function to clear all live logs and show a placeholder.
        function clearLiveLogs() {
          liveLogsContent.innerHTML = "<div class='placeholder' style='font-family: monospace; font-size: 12px; color: #888; text-align: center; padding: 10px;'>Waiting for next message...</div>";
        }

        // Clicking on the map resets any vessel focus.
map.on('click', () => {
  if (focusedVessel) {
    const vessel = vesselData[focusedVessel];
    vesselMarkers[focusedVessel].getTooltip().setContent(vessel.Name);
    vesselMarkers[focusedVessel].setZIndexOffset(0);
    focusedVessel = null;
    unsubscribeInstantUpdates();

    // Hide detail overlay and all related buttons when no vessel is focused.
    document.getElementById('vessel-detail').style.display = 'none';
    document.getElementById('toggle-detail-overlay').style.display = 'none';
    document.getElementById('live-logs').style.display = 'none';
    document.getElementById('stats-button').style.display = 'none';

    clearLiveLogs();
    updateFocussedVisibility();
  }
});


        // Mapping objects for Fix Type, Nav Status, and Static Message Types.
        const fixTypeMapping = { 0: "No Fix", 1: "GPS Fix", 2: "DGPS Fix" };

        const navigationalStatusMapping = {
          0: "Using Engine",
          1: "At Anchor",
          2: "Not Under Command",
          3: "Restricted Manoeuvrability",
          4: "Constrained by Draft",
          5: "Moored",
          6: "Aground",
          7: "Engaged in Fishing",
          8: "Under Way Sailing",
          15: "Not Defined"
        };

        const staticTypeMapping = {
          0: "Not available",
          1: "Reserved",
          2: "Reserved",
          3: "Reserved",
          4: "Reserved",
          5: "Reserved",
          6: "Reserved",
          7: "Reserved",
          8: "Reserved",
          9: "Reserved",
          10: "Reserved",
          11: "Reserved",
          12: "Reserved",
          13: "Reserved",
          14: "Reserved",
          15: "Reserved",
          16: "Reserved",
          17: "Reserved",
          18: "Reserved",
          19: "Reserved",
          20: "Wing in ground (WIG)",
          21: "Wing in ground (WIG)",
          22: "Wing in ground (WIG)",
          23: "Wing in ground (WIG)",
          24: "Wing in ground (WIG)",
          25: "Wing in ground (WIG)",
          26: "Wing in ground (WIG)",
          27: "Wing in ground (WIG)",
          28: "Wing in ground (WIG)",
          29: "Wing in ground (WIG)",
          30: "Fishing",
          31: "Towing",
          32: "Towing: length>200m, breadth>25m",
          33: "Dredging or underwater ops",
          34: "Diving ops",
          35: "Military ops",
          36: "Sailing",
          37: "Pleasure Craft",
          38: "Reserved",
          39: "Reserved",
          40: "High speed craft (HSC)",
          41: "High speed craft (HSC)",
          42: "High speed craft (HSC)",
          43: "High speed craft (HSC)",
          44: "High speed craft (HSC)",
          45: "High speed craft (HSC)",
          46: "High speed craft (HSC)",
          47: "High speed craft (HSC)",
          48: "High speed craft (HSC)",
          49: "High speed craft (HSC)",
          50: "Pilot Vessel",
          51: "Search and Rescue vessel",
          52: "Tug",
          53: "Port Tender",
          54: "Anti-pollution equipment",
          55: "Law Enforcement",
          56: "Spare - Local Vessel",
          57: "Spare - Local Vessel",
          58: "Medical Transport",
          59: "Noncombatant ship",
          60: "Passenger",
          61: "Passenger",
          62: "Passenger",
          63: "Passenger",
          64: "Passenger",
          65: "Passenger",
          66: "Passenger",
          67: "Passenger",
          68: "Passenger",
          69: "Passenger",
          70: "Cargo",
          71: "Cargo",
          72: "Cargo",
          73: "Cargo",
          74: "Cargo",
          75: "Cargo",
          76: "Cargo",
          77: "Cargo",
          78: "Cargo",
          79: "Cargo",
          80: "Tanker",
          81: "Tanker",
          82: "Tanker",
          83: "Tanker",
          84: "Tanker",
          85: "Tanker",
          86: "Tanker",
          87: "Tanker",
          88: "Tanker",
          89: "Tanker",
          90: "Other Type",
          91: "Other Type",
          92: "Other Type",
          93: "Other Type",
          94: "Other Type",
          95: "Other Type",
          96: "Other Type",
          97: "Other Type",
          98: "Other Type",
          99: "Other Type"
        };

const vesselColorPalette = [
  "#DC143C", // Crimson Red
  "#32CD32", // Bright Green
  "#FFD700", // Gold Yellow
  "#4169E1", // Royal Blue
  "#FF8C00", // Dark Orange
  "#8A2BE2", // Blue Violet
  "#00BFFF", // Deep Sky Blue
  "#FF00FF", // Fuchsia
  "#7FFF00", // Chartreuse
  "#008080", // Teal
  "#EE82EE", // Violet
  "#A52A2A", // Saddle Brown
  "#66CDAA", // Medium Aquamarine
  "#9ACD32", // Yellow Green
  "#FF7F50", // Coral
  "#1E90FF"  // Dodger Blue
];

// Hash function that returns a numeric index based on a string.
function hashStringToIndex(str, max) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  return Math.abs(hash) % max;
}

// Get a consistent color for a given vessel type.
// It uses staticTypeMapping (or falls back to the type itself) to get the description.
function getColorForVesselTypeConsistent(type) {
  // If the type is falsy (undefined, null, empty), return blue.
  if (!type) return "blue";
  const description = staticTypeMapping[type] || type;
  const index = hashStringToIndex(description, vesselColorPalette.length);
  return vesselColorPalette[index];
}


// Create a custom boat icon using your existing SVG, but with the stroke and fill set to the vessel type's color.
function createBoatIcon(type) {
  const color = getColorForVesselTypeConsistent(type);
  const svgHtml = `<svg width="20" height="50" viewBox="0 0 20 50">
    <path d="M5 45 L15 45 L15 30 Q10 5,5 30 Z" stroke="${color}" fill="${color}" stroke-width="2" />
  </svg>`;
  return L.divIcon({
    html: svgHtml,
    className: 'boat-icon',
    iconSize: [20, 50],
    iconAnchor: [10, 25],
    popupAnchor: [0, -25]
  });
}

function updateLatLongDisplay() {
  const latlongDisplay = document.getElementById('latlong-display');
  if (focusedVessel && vesselData[focusedVessel]) {
    const lat = vesselData[focusedVessel].Latitude;
    const lon = vesselData[focusedVessel].Longitude;
    if (typeof lat === 'number' && typeof lon === 'number') {
      latlongDisplay.innerHTML = `<strong>${lat.toFixed(4)}, ${lon.toFixed(4)}</strong>`;
    }
  }
}

function hydrateTrackHistory(userID) {
  fetch(`/history/${userID}/24`)
    .then(response => {
      if (!response.ok) {
        throw new Error(`History fetch failed with status: ${response.status}`);
      }
      return response.text();
    })
    .then(csvData => {
      // Parse the CSV formatted history into an array of points.
      // Each point is an array: [timestamp, latitude, longitude]
      const newPoints = csvData.trim().split('\n').map(line => {
        const parts = line.split(',');
        return [
          parts[0],                     // Timestamp string
          parseFloat(parts[1]),         // Latitude
          parseFloat(parts[2])          // Longitude
        ];
      });

      // Retrieve the current track history (or start with an empty array).
      const currentTrack = vesselData[userID].track || [];
      
      // Merge the current track with the new points.
      const mergedTrack = currentTrack.concat(newPoints);
      
      // Sort the merged track by time (assuming the timestamp is ISO formatted).
      mergedTrack.sort((a, b) => new Date(a[0]) - new Date(b[0]));

      // Remove duplicate entries.
      // Two points are considered duplicates if they have identical timestamp, latitude, and longitude.
      const dedupedTrack = [];
      mergedTrack.forEach(point => {
        if (
          dedupedTrack.length === 0 ||
          dedupedTrack[dedupedTrack.length - 1][0] !== point[0] ||
          dedupedTrack[dedupedTrack.length - 1][1] !== point[1] ||
          dedupedTrack[dedupedTrack.length - 1][2] !== point[2]
        ) {
          dedupedTrack.push(point);
        }
      });

      // Update the vessel's track history in your data store.
      vesselData[userID].track = dedupedTrack;
      
      // Update the polyline on the map with the new set of track points.
      if (vesselTracks[userID]) {
        // Update the existing polyline's coordinates.
        vesselTracks[userID].setLatLngs(getLatLngs(dedupedTrack));
        vesselTracks[userID].options.interactive = true; // Ensure interactivity
        
        // Reattach event handlers (if needed)
        vesselTracks[userID].on('mousemove', function(e) {
          const nearest = getNearestTrackPoint(e, vesselData[userID].track);
          if (nearest) {
            const [timestamp, lat, lon] = nearest.info;
            const localTime = new Date(timestamp).toLocaleString();
            const popupContent = `<strong>${localTime}</strong><br>
                                  ${lat.toFixed(4)}, ${lon.toFixed(4)}`;
            L.popup({ closeButton: false, autoPan: false })
              .setLatLng(nearest.ptLatLng)
              .setContent(popupContent)
              .openOn(map);
          }
        });
        vesselTracks[userID].on('mouseout', function() {
          map.closePopup();
        });
      } else {
        // Create a new polyline if it doesn't exist.
        vesselTracks[userID] = L.polyline(getLatLngs(dedupedTrack), {
          color: vesselData[userID].color,
          weight: 3,
          opacity: 0.8
        }).addTo(map);
      }
      
      // Save the updated vessel data back into localStorage.
      localStorage.setItem('vesselData', JSON.stringify(vesselData));
    })
    .catch(error => {
      console.error('Error hydrating track history:', error);
    });
}

        // Global objects to store markers, vessel data, and track histories.
        const vesselMarkers = {};
        const vesselData = {};   // keyed by MMSI/UserID
        const vesselTracks = {}; // keyed by MMSI/UserID

        /**
         * Decode the AIS communication state.
         */
        function decodeCommunicationState(state) {
          const intState = Number(state);
          const syncState = intState >> 17;
          const slotTimeout = (intState >> 14) & 0x07;
          const slotOffset = intState & 0x3FFF;
          return { syncState, slotTimeout, slotOffset };
        }

        /**
         * Build popup content from vessel data.
         */
function createPopupContent(data) {
  const lines = [];
  // Top line: Always show name, callsign, and class.
  let name = data.Name ? data.Name : "Unknown Vessel";
  if (data.CallSign) {
    name += ` (${data.CallSign})`;
  }
  if (data.AISClass) {
    name += ` | ${data.AISClass}`;
  }
  lines.push(`<strong>${name}</strong>`);

  // Add subsequent lines only if they have valid (non-null/non-empty) values.
  addLine(lines, "Last Update", data.lastUpdate ? timeAgo(data.lastUpdate) : null);
  addLine(lines, "MMSI", data.UserID);

  if (data.MID) {
    const midCode = lookupMID(data.MID);
    addLine(lines, "Country", midCode);
  }

  addLine(lines, "Destination", data.Destination && data.Destination.trim() !== "" ? data.Destination : null);
  addLine(lines, "Speed Over Ground", (data.Sog != null ? `${data.Sog} kn` : null));

  if (data.Type !== undefined) {
    const typeDescription = staticTypeMapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  addLine(lines, "Maximum Draught", (data.MaximumStaticDraught != null ? `${data.MaximumStaticDraught} m` : null));

  if (data.NavigationalStatus !== undefined) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}



   function lookupMID(mid) {
    if (mids.hasOwnProperty(mid)) {
       return mids[mid][3] || "Unknown";
    }
    return "Unknown";
   }


function buildTooltipLine(...values) {
  return values
    .filter(val => val !== null && val !== undefined && (typeof val === "string" ? val.trim() !== "" : true))
    .join(" | ");
}

// Helper to add a line if the value is valid
function addLine(lines, label, value, formatFn) {
  if (value !== null && value !== undefined && value !== "") {
    lines.push(`${label}: ${formatFn ? formatFn(value) : value}`);
  }
}

function getLatLngs(track) {
  return track.map(pt => [pt[1], pt[2]]);
}

function createDetailContent(data) {
  const lines = [];
  const lastSeen = data.lastUpdate ? timeAgo(data.lastUpdate) : null;
  addLine(lines, "Last Update", lastSeen);
  addLine(lines, "MMSI", data.UserID);
  addLine(lines, "AIS Class", data.AISClass);

  if (data.MID) {
    const midCode = lookupMID(data.MID);
    addLine(lines, "Country", midCode);
  }

  addLine(lines, "Call Sign", data.CallSign);
  addLine(lines, "IMO Number", data.ImoNumber);

  // Destination: show a default text if it's empty
  if (data.Destination && data.Destination.trim() !== "") {
    addLine(lines, "Destination", data.Destination);
  } else {
    lines.push("Destination: NO DEST");
  }

  addLine(lines, "Speed Over Ground", (data.Sog != null ? `${data.Sog} kn` : null));
  addLine(lines, "Course Over Ground", (data.Cog != null ? `${data.Cog}°` : null));

  if (data.Type != null) {
    const typeDescription = staticTypeMapping[data.Type] || data.Type;
    addLine(lines, "Type", typeDescription);
  }

  if (data.Dimension) {
    const d = data.Dimension;
    // Calculate overall length and width, but only add if non-zero.
    const totalLength = (Number(d.A) || 0) + (Number(d.B) || 0);
    const totalWidth = (Number(d.C) || 0) + (Number(d.D) || 0);
    if (totalLength > 0 && totalWidth > 0) {
      lines.push(`Dimensions: ${totalLength}m x ${totalWidth}m`);
    }
  }

  if (data.Eta) {
    const e = data.Eta;
    const now = new Date();
    const etaDate = new Date(now.getFullYear(), e.Month - 1, e.Day, e.Hour, e.Minute);
    const etaFormatted = etaDate.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    lines.push(`ETA: ${etaFormatted}`);
  }

  if (data.FixType != null) {
    const fixDescription = fixTypeMapping[data.FixType] || data.FixType;
    addLine(lines, "Fix Type", fixDescription);
  }

  addLine(lines, "Maximum Draught (m)", data.MaximumStaticDraught);
  addLine(lines, "Position Msg ID", data.MessageID);

  if (data.Latitude != null && data.Longitude != null) {
    addLine(lines, "Latitude", data.Latitude.toFixed(4));
    addLine(lines, "Longitude", data.Longitude.toFixed(4));
  }

  if (data.TrueHeading != null && data.TrueHeading < 360) {
    addLine(lines, "True Heading", `${data.TrueHeading}°`);
  }

  if (data.NavigationalStatus != null) {
    const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
    addLine(lines, "Nav Status", navStatusDescription);
  }

  addLine(lines, "Rate Of Turn", (data.RateOfTurn != null ? `${data.RateOfTurn}°/min` : null));
  addLine(lines, "Timestamp", data.Timestamp);
  addLine(lines, "Position Accuracy", data.PositionAccuracy);

  if (data.CommunicationState != null) {
    const comm = decodeCommunicationState(data.CommunicationState);
    lines.push("Communication State:");
    lines.push(`- Sync State: ${comm.syncState}`);
    lines.push(`- Slot Timeout: ${comm.slotTimeout}`);
    lines.push(`- Slot Offset: ${comm.slotOffset}`);
  }

  return `<div class="popup-content">${lines.join('<br>')}</div>`;
}



        // Adjust map bounds based on whether a vessel is focused.
        function adjustMapBounds() {
          if (focusedVessel) {
            let bounds = L.latLngBounds([]);
            bounds.extend(vesselMarkers[focusedVessel].getLatLng());
            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
          } else {
            const allLatLngs = [];
            for (const key in vesselMarkers) {
              if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
                allLatLngs.push(vesselMarkers[key].getLatLng());
              }
            }
            if (allLatLngs.length > 0) {
              map.fitBounds(allLatLngs, { padding: [50, 50] });
            }
         }
       }

        document.getElementById('auto-zoom').addEventListener('change', (event) => {
          if (event.target.checked) {
            adjustMapBounds();
          }
        });

        // Utility: Compute a time elapsed string.
        function timeAgo(timestamp) {
          const seconds = Math.floor((Date.now() - timestamp) / 1000);
          if (seconds < 60) return seconds + " sec ago";
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + " min ago";
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + " hrs ago";
          const days = Math.floor(hours / 24);
          return days + " days ago";
        }

function updateStationaryMarkers() {
  const showStationary = document.getElementById('stationary').checked;
  const onlyFocussed = document.getElementById('only-focussed').checked;
  const now = Date.now();

  for (const mmsi in vesselData) {
    const vesselState = vesselData[mmsi];

    // When "Only Tracked" is enabled, skip any vessel that's not focused.
    if (onlyFocussed && focusedVessel && mmsi !== focusedVessel) {
      if (vesselMarkers[mmsi] && map.hasLayer(vesselMarkers[mmsi])) {
        map.removeLayer(vesselMarkers[mmsi]);
      }
      if (vesselTracks[mmsi] && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
      continue; // Skip further processing for non-focused vessels.
    }

    if (vesselState.lastUpdate) {
      const ageSeconds = (now - vesselState.lastUpdate) / 1000;

if (!showStationary) {
  // Skip removal logic for the vessel in focus.
  if (mmsi !== focusedVessel) {
    // Remove vessel if it hasn't updated in over 120 seconds.
    if (ageSeconds > 120) {
      if (vesselMarkers[mmsi] && map.hasLayer(vesselMarkers[mmsi])) {
        map.removeLayer(vesselMarkers[mmsi]);
      }
      if (vesselTracks[mmsi] && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
      continue;
    }

    // Remove vessel if SOG is not a valid number or if it's stationary (<= 0.5 kn)
    if (typeof vesselState.Sog !== "number" || vesselState.Sog <= 0.5) {
      if (vesselMarkers[mmsi] && map.hasLayer(vesselMarkers[mmsi])) {
        map.removeLayer(vesselMarkers[mmsi]);
      }
      if (vesselTracks[mmsi] && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
      continue;
    }
  }
}

    }

    // If we haven't removed the marker, make sure markers and tracks are visible.
    if (vesselMarkers[mmsi] && !map.hasLayer(vesselMarkers[mmsi])) {
      map.addLayer(vesselMarkers[mmsi]);
    }
    if (vesselTracks[mmsi]) {
      const showPaths = document.getElementById('show-paths').checked;
      if (showPaths && !map.hasLayer(vesselTracks[mmsi])) {
        map.addLayer(vesselTracks[mmsi]);
      } else if (!showPaths && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
    }
  }

  if (document.getElementById('auto-zoom').checked) {
    adjustMapBounds();
  }
}


        // Update the known vessels overlay.
        function updateOverlay() {
          const filterText = document.getElementById('vessel-filter').value.toLowerCase();
          const vessels = Object.values(vesselData).filter(v =>
            v.Name && v.lastUpdate &&
            (!filterText ||
              v.Name.toLowerCase().includes(filterText) ||
              (v.CallSign && v.CallSign.toLowerCase().includes(filterText)) ||
              v.UserID.toString().includes(filterText)
            )
          );
	  document.getElementById('vessel-count').textContent = 'Total: ' + vessels.length;
          vessels.sort((a, b) => b.lastUpdate - a.lastUpdate);
          const topVessels = vessels.slice(0, 100);
          let content = "";
          topVessels.forEach(v => {
            const name = v.Name;
            const callsign = v.CallSign ? v.CallSign : "N/A";
            const lastSeen = timeAgo(v.lastUpdate);
            const numMessages = v.NumMessages || 0;
            content += `<div class="vessel-entry" data-userid="${v.UserID}">
                          <div class="vessel-name">${name}</div>
                          <div class="vessel-callsign">Call Sign: ${callsign}</div>
                          <div class="vessel-timestamp">${lastSeen} | ${numMessages} msgs</div>
                        </div>`;
          });
          document.getElementById('overlay-content').innerHTML = content;

          document.querySelectorAll('.vessel-entry').forEach(entry => {
            entry.addEventListener('click', (event) => {
              event.stopPropagation();
              const userID = entry.getAttribute('data-userid');
	      document.getElementById('stationary').checked = true;
	      updateStationaryMarkers();
              focusOnVessel(userID);
            });
          });
        }

        // Periodically update the vessel detail overlay.
        function updateVesselDetailOverlay() {
          if (!detailsOverlayHidden && focusedVessel && vesselData[focusedVessel]) {
            const detailContent = createDetailContent(vesselData[focusedVessel]);
            document.getElementById('detail-content').innerHTML = detailContent;
          }
        }
        setInterval(updateVesselDetailOverlay, 1000);
        setInterval(updateOverlay, 1000);

        // Update marker and track visibility based on the "Only Tracked" checkbox.
    function updateFocussedVisibility() {
      const onlyFocussed = document.getElementById('only-focussed').checked;
      const showPaths = document.getElementById('show-paths').checked;
      if (onlyFocussed && focusedVessel) {
        for (const userID in vesselMarkers) {
          if (userID !== focusedVessel.toString()) {
            if (map.hasLayer(vesselMarkers[userID])) map.removeLayer(vesselMarkers[userID]);
            if (vesselTracks[userID] && map.hasLayer(vesselTracks[userID])) {
              map.removeLayer(vesselTracks[userID]);
            }
          } else {
            if (!map.hasLayer(vesselMarkers[userID])) map.addLayer(vesselMarkers[userID]);
            if (vesselTracks[userID]) {
              if (showPaths && !map.hasLayer(vesselTracks[userID])) {
                map.addLayer(vesselTracks[userID]);
              } else if (!showPaths && map.hasLayer(vesselTracks[userID])) {
                map.removeLayer(vesselTracks[userID]);
              }
            }
          }
        }
      } else {
        for (const userID in vesselMarkers) {
          if (!map.hasLayer(vesselMarkers[userID])) map.addLayer(vesselMarkers[userID]);
        }
        for (const userID in vesselTracks) {
          if (showPaths) {
            if (!map.hasLayer(vesselTracks[userID])) map.addLayer(vesselTracks[userID]);
          } else {
            if (map.hasLayer(vesselTracks[userID])) map.removeLayer(vesselTracks[userID]);
          }
        }
      }
    }


        // --- Live Logs functionality ---
        const maxLogMessages = 250;
        const liveLogsContent = document.getElementById('live-logs-content');

        // Helper function to recursively format nested objects with indentation.
        function formatLogField(key, value, indentLevel = 0) {
          const indentStyle = `style="padding-left: ${indentLevel * 15}px"`;
          let html = `<div ${indentStyle}><span class="log-field">${key}:</span> `;
          if (value !== null && typeof value === 'object') {
            html += `<br>`;
            for (const subKey in value) {
              html += formatLogField(subKey, value[subKey], indentLevel + 1);
            }
          } else {
            html += `${value}`;
          }
          html += `</div>`;
          return html;
        }

        // Updated renderLogMessage function that uses the recursive formatter.
    function renderLogMessage(msg) {
      const logTimestamp = msg.timestamp
        ? new Date(msg.timestamp).toLocaleTimeString()
        : new Date().toLocaleTimeString();

      // Wrap the log entry in a container with a data-type attribute.
      let html = `<div class="log-entry" data-type="${msg.type}">`;
      html += `<div class="log-timestamp" style="font-size:10px;color:#888;margin-bottom:2px;">${logTimestamp}</div>`;
      html += formatLogField("Type", msg.type);

      for (const field in msg.data) {
        html += formatLogField(field, msg.data[field]);
      }

      html += '</div>';
      return html;
    }


    function subscribeInstantUpdates(userID) {
      // Build the channel name and subscribe.
      instantChannel = "ais_data/" + userID;
      socket.emit("subscribe", instantChannel);

      // Define the generic handler that updates the vessel's data
      // and its marker position on the map.
      instantHandler = function(message) {
        // Parse string messages if needed.
        if (typeof message === "string") {
          try {
            message = JSON.parse(message);
          } catch (e) {
            console.error("Error parsing message:", e);
            return;
          }
        }

        // Since we're subscribed to a single vessel's channel, no vessel filtering is needed here.
        // However, you can still filter by message type if you want.
        if (!allowedMessageTypes[message.type]) {
          return;
        }

        // Update each field present in the incoming message.
        if (message.data && message.data.UserID) {
          Object.keys(message.data).forEach(field => {
            vesselData[userID][field] = message.data[field];
          });
        }

        if (message.timestamp) {
          vesselData[userID].lastUpdate = new Date(message.timestamp).getTime();
        }

        // If the message includes a new position, update the marker position and popup.
        if (typeof message.data.Latitude === "number" &&
            typeof message.data.Longitude === "number") {
          if (vesselMarkers[userID]) {
            vesselMarkers[userID].setLatLng([message.data.Latitude, message.data.Longitude]);
            // Update popup content with the updated data.
            const popupContent = createPopupContent(vesselData[userID]);
            vesselMarkers[userID].getPopup().setContent(popupContent);
            if (focusedVessel === userID) {
              updateLatLongDisplay();
            }

            // If a new TrueHeading is provided, update the marker's rotation.
	    const heading =
		  (message.data.TrueHeading !== undefined && message.data.TrueHeading < 360)
		    ? message.data.TrueHeading
		    : message.data.Cog;
            if (heading !== undefined) {
              const markerElem = vesselMarkers[userID].getElement() || vesselMarkers[userID]._icon;
              if (markerElem) {
                const svg = markerElem.querySelector('svg');
                if (svg) {
                  svg.style.transform = `rotate(${heading}deg)`;
                }
              }
            }
          }
        }

        // Update the vessel detail overlay.
        updateVesselDetailOverlay();

        // Also, add the message to the live logs modal.
        addLiveLogEntry(message);
      };

      // Attach the handler.
      socket.on("ais_data", instantHandler);
    }

    function unsubscribeInstantUpdates() {
      if (instantChannel && instantHandler) {
        socket.emit("unsubscribe", instantChannel);
        socket.off("ais_data", instantHandler);
      }
      instantChannel = null;
      instantHandler = null;
    }

    function addLiveLogEntry(message) {
      // Remove the placeholder if it exists.
      const placeholder = liveLogsContent.querySelector('.placeholder');
      if (placeholder) {
        placeholder.remove();
      }

      // Render the log entry.
      const logHTML = renderLogMessage(message);
      liveLogsContent.insertAdjacentHTML('afterbegin', logHTML);

      // Get the newly added entry (assumed to be the first child).
      const newEntry = liveLogsContent.firstElementChild;
      // Save the original message object on the entry.
      newEntry.originalMessage = message;
      // Also save the full HTML so we can revert if no search is active.
      newEntry.dataset.fullHtml = newEntry.innerHTML;

      // Apply filters immediately.
      applyLogFilters();

      // Limit the total number of log entries.
      while (liveLogsContent.childElementCount > maxLogMessages) {
        liveLogsContent.removeChild(liveLogsContent.lastChild);
      }
    }


    function applyLogFilters() {
      const logEntries = liveLogsContent.querySelectorAll('.log-entry');
      const searchQuery = document.getElementById('live-log-search').value.toLowerCase();

      logEntries.forEach(entry => {
        // Get the message type from the data attribute.
        const type = entry.getAttribute('data-type');
        const matchesType = liveLogFilters[type];

        // If the type filter is not enabled, hide the entry.
        if (!matchesType) {
          entry.style.display = 'none';
          return;
        }

        // If there's no search query, revert to the full HTML.
        if (!searchQuery) {
          entry.innerHTML = entry.dataset.fullHtml;
          entry.style.display = '';
          return;
        }

        // If a search query exists, rebuild the content.
        const msg = entry.originalMessage;
        // Start with the timestamp.
        const logTimestamp = msg.timestamp
          ? new Date(msg.timestamp).toLocaleTimeString()
          : new Date().toLocaleTimeString();
        let newHtml = `<div class="log-timestamp" style="font-size:10px;color:#888;margin-bottom:2px;">${logTimestamp}</div>`;

        let fieldMatched = false;
        // Iterate over each field in the message data.
        for (const field in msg.data) {
          const value = msg.data[field];
          // Check if the field name or value matches the search query.
          if (
            field.toLowerCase().includes(searchQuery) ||
            String(value).toLowerCase().includes(searchQuery)
          ) {
            newHtml += formatLogField(field, value);
            fieldMatched = true;
          }
        }

        // If at least one field matched, show the new HTML; otherwise, hide the entry.
        if (fieldMatched) {
          entry.innerHTML = newHtml;
          entry.style.display = '';
        } else {
          entry.style.display = 'none';
        }
      });
    }



        // When the Live Logs button is clicked.
        document.getElementById('live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'block';
          clearLiveLogs();
        });

        // When the close button on the Live Logs overlay is clicked.
        document.getElementById('close-live-logs').addEventListener('click', () => {
          const overlay = document.getElementById('live-logs-overlay');
          overlay.style.display = 'none';
          clearLiveLogs();
        });

        // Make the Live Logs overlay draggable.
        (function makeDraggable() {
          const overlay = document.getElementById('live-logs-overlay');
          const header = document.getElementById('live-logs-header');
          let offsetX = 0, offsetY = 0, isDragging = false;

          header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - overlay.offsetLeft;
            offsetY = e.clientY - overlay.offsetTop;
          });

          document.addEventListener('mousemove', (e) => {
            if (isDragging) {
              overlay.style.left = (e.clientX - offsetX) + 'px';
              overlay.style.top = (e.clientY - offsetY) + 'px';
            }
          });

          document.addEventListener('mouseup', () => {
            isDragging = false;
          });
        })();

        // Load saved vessel data from localStorage if available.
        const storedData = localStorage.getItem('vesselData');
        if (storedData) {
          try {
            const parsedData = JSON.parse(storedData);
            Object.keys(parsedData).forEach(userID => {
              vesselData[userID] = parsedData[userID];
              if (
                vesselData[userID].Latitude !== undefined &&
                vesselData[userID].Longitude !== undefined
              ) {
                const lat = vesselData[userID].Latitude;
                const lon = vesselData[userID].Longitude;
                const popupContent = createPopupContent(vesselData[userID]);
                const marker = L.marker([lat, lon], { icon: createBoatIcon(vesselData[userID].Type || null) }).addTo(map);

		marker.on('add', function() {
		  const markerElem = marker.getElement();
		  if (markerElem) {
		    const svg = markerElem.querySelector('svg');
		    if (svg) {
		      const heading =
		        (vesselData[userID].TrueHeading !== undefined && vesselData[userID].TrueHeading < 360)
		          ? vesselData[userID].TrueHeading
		          : vesselData[userID].Cog;
		      if (heading !== undefined) {
		        svg.style.transform = `rotate(${heading}deg)`;
		      }
		    }
		  }
    	      if (markerElem) {
    	       const svg = markerElem.querySelector('svg');
    		 if (svg) {
    		    svg.addEventListener('click', (e) => {
    		      if (e && typeof e.stopPropagation === 'function') {
    		        e.stopPropagation();
    		      }
    		      focusOnVessel(userID);
    		    });
    		  }
    	       }
    	    });
                marker.bindPopup(popupContent, { autoPan: false });
                if (vesselData[userID].Name) {
                  marker.bindTooltip(vesselData[userID].Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(marker, userID);
                }
                marker.on('click', function(e) {
      	      if (e && typeof e.stopPropagation === 'function') {
    	        e.stopPropagation();
    	      }
    	      if (e && typeof e.preventDefault === 'function') {
    	        e.preventDefault();
    	      }
    	      focusOnVessel(userID);
    	    });
    	    const markerElem = marker.getElement() || marker._icon;
    	    if (markerElem) {
    	      markerElem.addEventListener('click', (e) => {
    	        if (e && typeof e.stopPropagation === 'function') {
    	          e.stopPropagation();
    	        }
       	    focusOnVessel(userID);
    	      });
    	    }
                if (!isMobile) {
                  marker.on('mouseover', function() { this.openPopup(); });
                  marker.on('mouseout', function() { this.closePopup(); });
                }
                vesselMarkers[userID] = marker;
              }
		if (vesselData[userID].track && vesselData[userID].track.length > 0) {
		  vesselTracks[userID] = L.polyline(getLatLngs(vesselData[userID].track), {
		    color: vesselData[userID].color,
		    weight: 3,
		    opacity: 0.8
		  }).addTo(map);
		}
            });
            adjustMapBounds();
            updateOverlay();
          } catch (e) {
            console.error("Error loading stored vessel data", e);
          }
        }

        // Listen for changes to the "Only Tracked" and "OpenSeaMap Overlay" checkboxes.
        document.getElementById('only-focussed').addEventListener('change', () => {
  	    updateFocussedVisibility();
	    updateStationaryMarkers(); // Reapply stationary filtering
	});
        document.getElementById('openseamap-overlay').addEventListener('change', () => {
          const overlayEnabled = document.getElementById('openseamap-overlay').checked;
          if (overlayEnabled) {
            if (!map.hasLayer(openSeaMapLayer)) {
              map.addLayer(openSeaMapLayer);
            }
          } else {
            if (map.hasLayer(openSeaMapLayer)) {
              map.removeLayer(openSeaMapLayer);
            }
          }
        });

        // Connect to the Socket.IO server.
        const socket = io();
        let instantChannel = null;
        let instantHandler = null;

        // Listen for the socket connection event.
        socket.on('connect', () => {
          document.getElementById('status-dot').style.background = 'green';
          document.getElementById('status-text').textContent = 'Connected';
	  // If a vessel is focused, resubscribe to its channel.
	  if (focusedVessel) {
	    subscribeInstantUpdates(focusedVessel);
  	}
        });

        // Listen for the socket disconnection event.
        socket.on('disconnect', () => {
          document.getElementById('status-dot').style.background = 'red';
          document.getElementById('status-text').textContent = 'Disconnected';
        });

        // Listen on "latest_vessel_data" which now provides a complete vessel state object.
        socket.on("latest_vessel_summary", (data) => {
          if (typeof data === "string") {
            try {
              data = JSON.parse(data);
            } catch (e) {
              console.error("Failed to parse JSON:", e);
              return;
            }
          }
          if (typeof data !== "object" || Array.isArray(data)) {
            console.error("Received invalid data format:", data);
            return;
          }
          const newIDs = new Set(Object.keys(data));
          for (const mmsi in vesselData) {
            if (!newIDs.has(mmsi)) {
              console.log("Removing vessel with MMSI:", mmsi);
              if (vesselMarkers[mmsi]) map.removeLayer(vesselMarkers[mmsi]);
              if (vesselTracks[mmsi]) map.removeLayer(vesselTracks[mmsi]);
              delete vesselData[mmsi];
              delete vesselMarkers[mmsi];
              delete vesselTracks[mmsi];
            }
          }
          for (const mmsi in data) {
            const vesselState = data[mmsi];
            if (!vesselData[mmsi]) {
              vesselData[mmsi] = Object.assign({}, vesselState);
              vesselData[mmsi].track = [];
              vesselData[mmsi].color = randomColor();
            } else {
              Object.assign(vesselData[mmsi], vesselState);
            }
            vesselData[mmsi].LastUpdated = vesselState.LastUpdated;
            vesselData[mmsi].lastUpdate = new Date(vesselState.LastUpdated).getTime();
            if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
              const tolerance = 1e-5;
              const track = vesselData[mmsi].track;
              const lastPoint = track[track.length - 1];
              if (!lastPoint || Math.abs(lastPoint[0] - vesselState.Latitude) > tolerance || Math.abs(lastPoint[1] - vesselState.Longitude) > tolerance) {
                track.push([vesselState.LastUpdated, vesselState.Latitude, vesselState.Longitude]);
                if (track.length > 10000) {
                  track.shift();
                }
              }
            }

            const popupContent = createPopupContent(vesselData[mmsi]);
            if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
              const lat = vesselState.Latitude;
              const lon = vesselState.Longitude;
              if (vesselMarkers[mmsi]) {
                vesselMarkers[mmsi].setLatLng([lat, lon]);
                vesselMarkers[mmsi].getPopup().setContent(popupContent);
    	    const markerElem = vesselMarkers[mmsi].getElement() || vesselMarkers[mmsi]._icon;
    	    if (markerElem) {
    	      const svg = markerElem.querySelector('svg');
    	      if (svg) {
    	        svg.style.transform = `rotate(${vesselState.TrueHeading}deg)`;
    	      }
    	      // Add the enlarge effect
    	      markerElem.classList.add('enlarge');
    	      setTimeout(() => markerElem.classList.remove('enlarge'), 500);
    	    }
                if (vesselState.Name && mmsi !== focusedVessel) {
                  vesselMarkers[mmsi].unbindTooltip();
                  vesselMarkers[mmsi].bindTooltip(vesselState.Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(vesselMarkers[mmsi], mmsi);
                }
                vesselMarkers[mmsi].off('click');
                vesselMarkers[mmsi].on('click', function(e) {
                  e.stopPropagation();
                  e.preventDefault();
                  focusOnVessel(mmsi);
                });
                if (markerElem) {
                  markerElem.classList.add('enlarge');
                  setTimeout(() => markerElem.classList.remove('enlarge'), 500);
                }
              } else {
                const marker = L.marker([lat, lon], { icon: createBoatIcon(vesselData[mmsi].Type || null) }).addTo(map);


                marker.bindPopup(popupContent, { autoPan: false });
                if (vesselState.Name) {
                  marker.bindTooltip(vesselState.Name, {
                    permanent: true,
                    direction: 'top',
                    className: 'vessel-tooltip',
                    interactive: true
                  }).openTooltip();
                  attachTooltipClick(marker, mmsi);
                }
                marker.on('click', function(e) {
                  e.stopPropagation();
                  e.preventDefault();
                  focusOnVessel(mmsi);
                });
                if (!isMobile) {
                  marker.on('mouseover', function() { this.openPopup(); });
                  marker.on('mouseout', function() { this.closePopup(); });
                }
                vesselMarkers[mmsi] = marker;
              }
              if (vesselTracks[mmsi]) {
		  vesselTracks[mmsi].setLatLngs(getLatLngs(vesselData[mmsi].track));
	      } else {
		  vesselTracks[mmsi] = L.polyline(getLatLngs(vesselData[mmsi].track), {
		    color: vesselData[mmsi].color,
		    weight: 3,
		    opacity: 0.8
		  }).addTo(map);
	      }

            } else {
              if (vesselMarkers[mmsi]) {
                vesselMarkers[mmsi].getPopup().setContent(popupContent);
                vesselMarkers[mmsi].unbindTooltip();
                vesselMarkers[mmsi].bindTooltip(popupContent, {
                  direction: 'top',
                  className: 'vessel-tooltip'
                });
              }
            }
            if (focusedVessel && focusedVessel == mmsi && !detailsOverlayHidden) {
              if (isMobile) {
                map.panTo(vesselMarkers[mmsi].getLatLng());
              } else {
                focusOnVessel(mmsi, false);
              }
            }
          }
          updateOverlay();
          updateFocussedVisibility();
	  updateStationaryMarkers();
          localStorage.setItem('vesselData', JSON.stringify(vesselData));
          if (document.getElementById('auto-zoom').checked) {
            adjustMapBounds();
          }
        });

        document.getElementById('vessel-filter').addEventListener('input', updateOverlay);

        document.getElementById('clear-history').addEventListener('click', () => {
          localStorage.removeItem('vesselData');
          Object.keys(vesselMarkers).forEach(userID => {
            map.removeLayer(vesselMarkers[userID]);
          });
          Object.keys(vesselTracks).forEach(userID => {
            map.removeLayer(vesselTracks[userID]);
          });
          Object.keys(vesselData).forEach(key => delete vesselData[key]);
          Object.keys(vesselMarkers).forEach(key => delete vesselMarkers[key]);
          Object.keys(vesselTracks).forEach(key => delete vesselTracks[key]);
          updateOverlay();
          location.reload();
        });

	document.getElementById('stationary').addEventListener('change', updateStationaryMarkers);

        // Attach tooltip click listener.
        function attachTooltipClick(marker, userID) {
          setTimeout(() => {
            const tooltip = marker.getTooltip();
            if (tooltip) {
              const ttEl = tooltip.getElement();
              if (ttEl) {
                ttEl.addEventListener('click', (e) => {
                  e.stopPropagation();
                  focusOnVessel(userID);
                });
              }
            }
          }, 0);
        }

	let lastFetchedUserID = null;

	function fetchMissingData(userID) {
	  // Only fetch if this vessel hasn't already had its missing data fetched this selection.
	  if (lastFetchedUserID === userID) return;

	  fetch(`/state/${userID}`)
	    .then(response => {
	      if (!response.ok) {
	        throw new Error(`Network response was not ok (${response.status})`);
	      }
	      return response.json();
	    })
	    .then(data => {
	      Object.assign(vesselData[userID], data);
	      updateVesselDetailOverlay();
	      lastFetchedUserID = userID;
	    })
	    .catch(err => {
	      console.error("Error fetching missing vessel data:", err);
	    });
	}

// Function to find the nearest point on the polyline track to the mouse event latlng.
function getNearestTrackPoint(e, track) {
  const mouseLatLng = e.latlng;
  let minDistance = Infinity;
  let nearestPoint = null;
  
  // Iterate over each point in the track (each point is [timestamp, lat, lon])
  track.forEach(pt => {
    // Create a Leaflet LatLng object for comparison.
    const ptLatLng = L.latLng(pt[1], pt[2]);
    const distance = mouseLatLng.distanceTo(ptLatLng);
    if (distance < minDistance) {
      minDistance = distance;
      nearestPoint = { ptLatLng, info: pt };
    }
  });
  return nearestPoint;
}


// Focus on a particular vessel.
function focusOnVessel(userID, initialFocus = true) {
  if (focusedVessel !== userID) {
    clearLiveLogs();
    if (instantChannel) {
      unsubscribeInstantUpdates();
    }
    subscribeInstantUpdates(userID);
    hydrateTrackHistory(userID);
  }

  // Reset tooltip for previous focused vessel.
  if (focusedVessel && focusedVessel !== userID) {
    const prevVessel = vesselData[focusedVessel];
    vesselMarkers[focusedVessel].getTooltip().setContent(prevVessel.Name);
    vesselMarkers[focusedVessel].setZIndexOffset(0);
  }

  focusedVessel = userID;
  vesselMarkers[userID].setZIndexOffset(1000);
  const vessel = vesselData[userID];

  updateLatLongDisplay();

  // Build two lines for additional details.
  // For example, line 1: Destination and Navigation Status.
  const line1 = buildTooltipLine(
    vessel.Destination,
    navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus
  );
  // And line 2: Vessel Type, Maximum Draught, Speed, and True Heading.
  const line2 = buildTooltipLine(
    staticTypeMapping[vessel.Type] || vessel.Type,
    (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
    (vessel.Sog != null ? `${vessel.Sog} kn` : null),
    (vessel.TrueHeading != null ? `${vessel.TrueHeading}°` : null)
  );

  // The tooltip now has the top line (vessel.Name) and two additional lines.
  const newTooltipContent = `${vessel.Name} (${vessel.CallSign})<br>${line1}<br>${line2}`;
  vesselMarkers[userID].getTooltip().setContent(newTooltipContent);

       const tooltipEl = vesselMarkers[userID].getTooltip().getElement();
       if (tooltipEl) {
	  tooltipEl.style.zIndex = '1100';
       }

       document.getElementById('toggle-detail-overlay').style.display = 'block';
       document.getElementById('live-logs').style.display = 'block';
       document.getElementById('stats-button').style.display = 'block';

       const detailOverlay = document.getElementById('vessel-detail');
       if (!detailsOverlayHidden) {
          detailOverlay.style.display = 'block';
          document.getElementById('toggle-detail-overlay').textContent = 'Hide Details';
       } else {
          detailOverlay.style.display = 'none';
          document.getElementById('toggle-detail-overlay').textContent = 'Show Details';
       }

	    const headerEl = document.getElementById('vessel-detail-header');
	    if (vesselData[userID].UserID) {
	      // Build the Lookup link and add a (Link) button after the vessel name.
	      headerEl.innerHTML = `${vesselData[userID].Name}
	        <br><a href="https://www.marinetraffic.com/en/ais/details/ships/mmsi:${vesselData[userID].UserID}" target="_blank">Lookup</a> |
	        <span id="copy-link" style="cursor:pointer; color:blue;">Link</span>`;
	    } else {
	      headerEl.textContent = "Vessel Details";
	    }

const copyLinkEl = document.getElementById('copy-link');
if (copyLinkEl) {
  copyLinkEl.addEventListener('click', (e) => {
    e.stopPropagation();
    const currentUrl = window.location.href.split('?')[0];
    const copyUrl = `${currentUrl}?UserID=${vesselData[userID].UserID}`;

    // Function to update the text temporarily
    function updateLinkText(newText) {
      copyLinkEl.textContent = newText;
      setTimeout(() => {
        copyLinkEl.textContent = "Link";
      }, 2000); // 2 seconds delay before reverting back
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(copyUrl).then(() => {
        updateLinkText("Link Copied");
      }).catch(err => {
        console.error("Failed to copy: ", err);
      });
    } else {
      // Fallback using a temporary textarea
      const textArea = document.createElement("textarea");
      textArea.value = copyUrl;
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        updateLinkText("Link Copied");
      } catch (err) {
        console.error("Fallback: Unable to copy", err);
      }
      document.body.removeChild(textArea);
    }
  });
}


// Helper function to show flash message
function showFlashMessage(message, parentEl) {
  const flashMsg = document.createElement('span');
  flashMsg.textContent = ` ${message}`;
  flashMsg.style.color = 'green';
  parentEl.appendChild(flashMsg);
  setTimeout(() => {
    flashMsg.remove();
  }, 1000);
}


         // Update the Live Logs modal title with the vessel name.
         const liveLogsTitle = document.getElementById('live-logs-title');
         if (vesselData[userID].Name) {
           liveLogsTitle.textContent = `${vesselData[userID].Name}`;
         } else {
           liveLogsTitle.textContent = 'Live Messages';
         }
          const detailContent = createDetailContent(vesselData[userID]);
          document.getElementById('detail-content').innerHTML = detailContent;

	  // Fetch missing data from /state/<UserID> and update overlay.
	  fetchMissingData(userID);

          if (initialFocus || document.getElementById('auto-zoom').checked) {
            let bounds = L.latLngBounds([]);
            bounds.extend(vesselMarkers[userID].getLatLng());
            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
          }

          updateFocussedVisibility();
        }

        document.getElementById('toggle-known-overlay').addEventListener('click', function() {
          const overlay = document.getElementById('vessel-overlay');
          const currentDisplay = window.getComputedStyle(overlay).display;
          if (currentDisplay === 'none') {
            overlay.style.display = 'block';
            this.textContent = 'Hide Vessels';
          } else {
            overlay.style.display = 'none';
            this.textContent = 'Show Vessels';
          }
        });

        document.getElementById('toggle-detail-overlay').addEventListener('click', function() {
          const detailOverlay = document.getElementById('vessel-detail');
          if (detailOverlay.style.display === 'none' || detailOverlay.style.display === '') {
            detailOverlay.style.display = 'block';
            this.textContent = 'Hide Details';
            detailsOverlayHidden = false;
          } else {
            detailOverlay.style.display = 'none';
            this.textContent = 'Show Details';
            detailsOverlayHidden = true;
          }
       });

    const liveLogFilters = {
      "ais.PositionReport": true,
      "ais.ShipStaticData": true,
      "ais.StandardClassBPositionReport": true,
      "ais.ExtendedClassBPositionReport": true
    };

    document.querySelectorAll('.log-filter').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        liveLogFilters[this.value] = this.checked;
        applyLogFilters();  // Use the new filter state in your live logs
      });
    });

       document.getElementById('stats-button').addEventListener('click', () => {
         if (focusedVessel) {
           // Open popup window with the current vessel's UserID.
           window.open('/stats.html?UserID=' + focusedVessel, '_blank', 'width=400,height=600');
         }
       });

       window.addEventListener('load', () => {
	 updateStationaryMarkers();
         adjustMapBounds();
	 // Check if a "UserID" query parameter exists in the URL.
	 const urlParams = new URLSearchParams(window.location.search);
	 const userID = urlParams.get("UserID");
	 if (userID) {
	   // Set an interval to wait for the vessel data to load.
	   const checkVesselInterval = setInterval(() => {
	     if (vesselData[userID]) {
	       focusOnVessel(userID);
	       clearInterval(checkVesselInterval);
	     }
	   }, 1000); // Check every 1 second (adjust as needed)
	 }
       });

    document.getElementById('show-paths').addEventListener('change', function() {
      const showPaths = this.checked;
      for (const mmsi in vesselTracks) {
        const vessel = vesselData[mmsi];
        const hasCallSign = vessel && (vessel.CallSign || "").trim().length > 0;
        if (showPaths && (hasCallSign || showNoCallsign)) {
          if (!map.hasLayer(vesselTracks[mmsi])) {
            map.addLayer(vesselTracks[mmsi]);
          }
        } else {
          if (map.hasLayer(vesselTracks[mmsi])) {
            map.removeLayer(vesselTracks[mmsi]);
          }
        }
      }
      updateFocussedVisibility();
    });

// Conversion: 1 nautical mile = 1852 meters.
function updateNauticalScale() {
  const scaleLabel = document.getElementById('scale-label');
  // Fixed pixel length for the scale bar (100px in this example)
  const scalePx = 100;
  const center = map.getCenter();
  // Convert the center to container coordinates.
  const point = map.latLngToContainerPoint(center);
  // Create a point that is 'scalePx' pixels to the right.
  const pointX = L.point(point.x + scalePx, point.y);
  // Convert that back to geographic coordinates.
  const latLngX = map.containerPointToLatLng(pointX);
  // Calculate the distance in meters.
  const distanceMeters = center.distanceTo(latLngX);
  // Convert meters to nautical miles.
  const distanceNM = distanceMeters / 1852;
  // Update the scale label with the value rounded to one decimal place.
  scaleLabel.textContent = `${distanceNM.toFixed(1)} NM`;
}

// Update the scale whenever the map is zoomed or moved.
map.on('zoomend moveend', updateNauticalScale);
// Call once to set the initial scale.
updateNauticalScale();

function updateFocussedTooltip() {
  if (focusedVessel && vesselData[focusedVessel]) {
    const vessel = vesselData[focusedVessel];
    const line1 = buildTooltipLine(
      vessel.Destination,
      navigationalStatusMapping[vessel.NavigationalStatus] || vessel.NavigationalStatus
    );
    const line2 = buildTooltipLine(
      staticTypeMapping[vessel.Type] || vessel.Type,
      (vessel.MaximumStaticDraught != null ? `${vessel.MaximumStaticDraught} m` : null),
      (vessel.Sog != null ? `${vessel.Sog} kn` : null),
      (vessel.TrueHeading != null ? `${vessel.TrueHeading}°` : null)
    );

    const newTooltipContent = `${vessel.Name} (${vessel.CallSign})<br>${line1}<br>${line2}`;
    vesselMarkers[focusedVessel].getTooltip().setContent(newTooltipContent);
  }
}
setInterval(updateFocussedTooltip, 1000);

    document.getElementById('live-log-search').addEventListener('input', applyLogFilters);

        // Utility: Generate a random hex color.
        function randomColor() {
          return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }
    </script>
</body>

</html>