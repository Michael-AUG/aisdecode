<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AIS Tracker</title>
  <!-- Leaflet CSS (from CDN, without integrity) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" crossorigin=""/>
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .popup-content {
      font-family: Arial, sans-serif;
      font-size: 14px;
      line-height: 1.3;
    }
    .boat-icon {
      background: transparent;
      border: none;
      transition: transform 0.5s ease-out;
    }
    /* CSS for the enlargement animation */
    .boat-icon.enlarge {
      transform: scale(1.5);
    }
    .vessel-tooltip {
      font-family: Arial, sans-serif;
      font-size: 10px;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.9);
      padding: 2px 4px;
      border: 1px solid #aaa;
      border-radius: 3px;
      cursor: pointer;
    }
    /* Style for the Clear History button */
    #clear-history {
      position: absolute;
      bottom: 25px;
      left: 10px;
      background: yellow;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      font-weight: bold;
      z-index: 1000;
    }
    /* Style for the known vessels overlay (bottom left) */
    #vessel-overlay {
      position: absolute;
      bottom: 100px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px;
      height: 300px;
      width: 150px;
      overflow-y: auto;
      z-index: 1000;
      font-family: Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
    }
    #vessel-overlay h4 {
      margin: 5px 0;
      text-align: center;
      font-size: 14px;
    }
    /* Style for the filter input box */
    #vessel-filter {
      width: 90%;
      margin: 5px auto;
      display: block;
      padding: 3px;
      font-size: 13px;
    }
    #vessel-overlay .vessel-entry {
      border-bottom: 1px solid #eee;
      padding: 4px 0;
      cursor: pointer;
    }
    #vessel-overlay .vessel-entry:last-child {
      border-bottom: none;
    }
    #vessel-overlay .vessel-name {
      font-weight: bold;
      text-decoration: underline;
    }
    #vessel-overlay .vessel-callsign {
      color: #555;
    }
    #vessel-overlay .vessel-timestamp {
      color: #888;
      font-size: 12px;
    }
    /* New Style for the vessel detail overlay (bottom right) */
    #vessel-detail {
      position: absolute;
      bottom: 80px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px;
      max-height: 300px;
      min-width: 200px;
      width: auto;
      overflow-y: auto;
      z-index: 1000;
      font-family: Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      display: none;
      white-space: nowrap;
    }
    #vessel-detail h4 {
      margin: 5px 0;
      text-align: center;
      font-size: 14px;
    }
    /* Style for the controls overlay */
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      z-index: 1000;
      font-family: Arial, sans-serif;
      font-size: 14px;
    }
    #controls label {
      cursor: pointer;
      display: block;
      margin-bottom: 5px;
    }
    /* Styles for the new toggle buttons */
    .toggle-button {
      position: absolute;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 3px 6px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      cursor: pointer;
      z-index: 1100;
    }
    #toggle-known-overlay {
      bottom: 70px;
      left: 10px;
    }
    #toggle-detail-overlay {
      bottom: 50px;
      right: 10px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Controls Overlay -->
  <div id="controls">
    <label>
      <input type="checkbox" id="auto-zoom" checked>
      Auto Zoom
    </label>
    <label>
      <input type="checkbox" id="only-focussed">
      Only Tracked
    </label>
    <label>
      <input type="checkbox" id="openseamap-overlay" checked>
      Map Overlay
    </label>
    <label>
     <input type="checkbox" id="filter-nocallsign">
     No Callsign
    </label>
  </div>
  
  <!-- Known vessels overlay (bottom left) -->
  <div id="vessel-overlay">
    <!-- Filter input box -->
    <input type="text" id="vessel-filter" placeholder="Filter vessels...">
    <div id="overlay-content"></div>
  </div>
  
  <!-- Vessel detail overlay (bottom right) -->
  <div id="vessel-detail">
    <h4 id="vessel-detail-header">Vessel Details</h4>
    <div id="detail-content"></div>
  </div>
  
  <!-- Toggle Buttons -->
  <button id="toggle-known-overlay" class="toggle-button">Hide Vessels</button>
  <button id="toggle-detail-overlay" class="toggle-button" style="display: none;">Hide Details</button>
  
  <button id="clear-history">Clear History</button>

  <!-- Socket.IO client (local copy) -->
  <script src="socket.io.min.js"></script>
  <!-- Leaflet JS (from CDN, without integrity) -->
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" crossorigin=""></script>
  <script>
    // Detect if the device is touch capable.
    const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
    // Flag to track if the user manually hid the details overlay.
    let detailsOverlayHidden = false;

    // Global variable to store the currently focused vessel (if any).
    let focusedVessel = null;

    // Initialize the Leaflet map.
    const map = L.map('map').setView([55.0, -3.0], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // OpenSeaMap overlay layer (enabled by default).
    const openSeaMapLayer = L.tileLayer('http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
      attribution: 'Map data: &copy; OpenSeaMap contributors'
    }).addTo(map);

    // Clicking on the map resets any vessel focus.
    map.on('click', () => {
      if (focusedVessel) {
        focusedVessel = null;
        document.getElementById('vessel-detail').style.display = 'none';
        document.getElementById('toggle-detail-overlay').style.display = 'none';
        detailsOverlayHidden = false;
        document.getElementById('auto-zoom').checked = true;
        updateFocussedVisibility();
        adjustMapBounds();
      }
    });

    // Define a custom boat icon using inline SVG.
    const boatIcon = L.divIcon({
      html: '<svg width="24" height="24" viewBox="0 0 24 24">' +
              '<path d="M2,16 L12,4 L22,16 L2,16 Z" fill="blue" />' +
              '<rect x="11" y="4" width="2" height="6" fill="white"/>' +
            '</svg>',
      className: 'boat-icon',
      iconSize: [24, 24],
      iconAnchor: [12, 12],
      popupAnchor: [0, -12]
    });

    // Mapping objects for Fix Type, Nav Status, and Static Message Types.
    const fixTypeMapping = {
      0: "No Fix",
      1: "GPS Fix",
      2: "DGPS Fix"
    };

    const navigationalStatusMapping = {
      0: "Using Engine",
      1: "At Anchor",
      2: "Not Under Command",
      3: "Restricted Manoeuvrability",
      4: "Constrained by Draft",
      5: "Moored",
      6: "Aground",
      7: "Engaged in Fishing",
      8: "Under Way Sailing",
      15: "Not Defined"
    };

    const staticTypeMapping = {
      0: "Not available (default)",
      1: "Reserved for future use",
      2: "Reserved for future use",
      3: "Reserved for future use",
      4: "Reserved for future use",
      5: "Reserved for future use",
      6: "Reserved for future use",
      7: "Reserved for future use",
      8: "Reserved for future use",
      9: "Reserved for future use",
      10: "Reserved for future use",
      11: "Reserved for future use",
      12: "Reserved for future use",
      13: "Reserved for future use",
      14: "Reserved for future use",
      15: "Reserved for future use",
      16: "Reserved for future use",
      17: "Reserved for future use",
      18: "Reserved for future use",
      19: "Reserved for future use",
      20: "Wing in ground (WIG)",
      21: "Wing in ground (WIG)",
      22: "Wing in ground (WIG)",
      23: "Wing in ground (WIG)",
      24: "Wing in ground (WIG)",
      25: "Wing in ground (WIG)",
      26: "Wing in ground (WIG)",
      27: "Wing in ground (WIG)",
      28: "Wing in ground (WIG)",
      29: "Wing in ground (WIG)",
      30: "Fishing",
      31: "Towing",
      32: "Towing: length exceeds 200m or breadth exceeds 25m",
      33: "Dredging or underwater ops",
      34: "Diving ops",
      35: "Military ops",
      36: "Sailing",
      37: "Pleasure Craft",
      38: "Reserved",
      39: "Reserved",
      40: "High speed craft (HSC)",
      41: "High speed craft (HSC)",
      42: "High speed craft (HSC)",
      43: "High speed craft (HSC)",
      44: "High speed craft (HSC)",
      45: "High speed craft (HSC)",
      46: "High speed craft (HSC)",
      47: "High speed craft (HSC)",
      48: "High speed craft (HSC)",
      49: "High speed craft (HSC)",
      50: "Pilot Vessel",
      51: "Search and Rescue vessel",
      52: "Tug",
      53: "Port Tender",
      54: "Anti-pollution equipment",
      55: "Law Enforcement",
      56: "Spare - Local Vessel",
      57: "Spare - Local Vessel",
      58: "Medical Transport",
      59: "Noncombatant ship according to RR Resolution No. 18",
      60: "Passenger",
      61: "Passenger",
      62: "Passenger",
      63: "Passenger",
      64: "Passenger",
      65: "Passenger",
      66: "Passenger",
      67: "Passenger",
      68: "Passenger",
      69: "Passenger",
      70: "Cargo",
      71: "Cargo",
      72: "Cargo",
      73: "Cargo",
      74: "Cargo",
      75: "Cargo",
      76: "Cargo",
      77: "Cargo",
      78: "Cargo",
      79: "Cargo",
      80: "Tanker",
      81: "Tanker",
      82: "Tanker",
      83: "Tanker",
      84: "Tanker",
      85: "Tanker",
      86: "Tanker",
      87: "Tanker",
      88: "Tanker",
      89: "Tanker",
      90: "Other Type",
      91: "Other Type",
      92: "Other Type",
      93: "Other Type",
      94: "Other Type",
      95: "Other Type",
      96: "Other Type",
      97: "Other Type",
      98: "Other Type",
      99: "Other Type"
    };

    // Global objects to store markers, vessel data, and track histories.
    const vesselMarkers = {};
    const vesselData = {};   // keyed by MMSI/UserID
    const vesselTracks = {}; // keyed by MMSI/UserID

    /**
     * Decode the AIS communication state.
     */
    function decodeCommunicationState(state) {
      const intState = Number(state);
      const syncState = intState >> 17;
      const slotTimeout = (intState >> 14) & 0x07;
      const slotOffset = intState & 0x3FFF;
      return { syncState, slotTimeout, slotOffset };
    }

    /**
     * Build popup content from vessel data.
     * Now the vessel object contains all relevant fields directly.
     */
    function createPopupContent(data) {
      const lines = [];
      const name = data.Name ? data.Name : "Unknown Vessel";
      const lastSeen = data.lastUpdate ? timeAgo(data.lastUpdate) : "N/A";
      lines.push(`<strong>${name}</strong>`);
      lines.push(`Last Update: ${lastSeen}`);
      lines.push(`MMSI: ${data.UserID}`);
      if (data.CallSign) { lines.push(`Call Sign: ${data.CallSign}`); }
      if (data.ImoNumber) { lines.push(`IMO Number: ${data.ImoNumber}`); }
      if (data.Destination) { lines.push(`Destination: ${data.Destination}`); }
      if (data.Sog !== undefined) { lines.push(`Speed Over Ground: ${data.Sog} kn`); }
      if (data.Cog !== undefined) { lines.push(`Course Over Ground: ${data.Cog}°`); }
      if (data.Type !== undefined) { 
        const typeDescription = staticTypeMapping[data.Type] || data.Type;
        lines.push(`Type: ${typeDescription}`);
      }
      if (data.Dimension) {
        const d = data.Dimension;
        lines.push(`Dimensions (from ref):`);
        lines.push(`- bow: ${d.A} m`);
        lines.push(`- stern: ${d.B} m`);
        lines.push(`- port: ${d.C} m`);
        lines.push(`- starboard: ${d.D} m`);
      }
      if (data.Eta) {
        const e = data.Eta;
        const now = new Date();
        const etaDate = new Date(now.getFullYear(), e.Month - 1, e.Day, e.Hour, e.Minute);
        const etaFormatted = etaDate.toLocaleString('ja-JP', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        lines.push(`ETA: ${etaFormatted}`);
      }
      if (data.FixType !== undefined) {
        const fixDescription = fixTypeMapping[data.FixType] || data.FixType;
        lines.push(`Fix Type: ${fixDescription}`);
      }
      if (data.MaximumStaticDraught !== undefined) { 
        lines.push(`Maximum Draught (m): ${data.MaximumStaticDraught}`); 
      }
      // Positional information
      lines.push(`Position Msg ID: ${data.MessageID}`);
      if (data.Latitude !== undefined && data.Longitude !== undefined) {
        lines.push(`Latitude: ${data.Latitude.toFixed(4)}`);
        lines.push(`Longitude: ${data.Longitude.toFixed(4)}`);
      }
      if (data.TrueHeading !== undefined && data.TrueHeading < 360) { 
        lines.push(`True Heading: ${data.TrueHeading}°`); 
      }
      if (data.NavigationalStatus !== undefined) {
        const navStatusDescription = navigationalStatusMapping[data.NavigationalStatus] || data.NavigationalStatus;
        lines.push(`Nav Status: ${navStatusDescription}`);
      }
      if (data.RateOfTurn !== undefined) { 
        lines.push(`Rate Of Turn: ${data.RateOfTurn}°/min`); 
      }
      if (data.Timestamp !== undefined) { 
        lines.push(`Timestamp: ${data.Timestamp}`); 
      }
      if (data.PositionAccuracy !== undefined) { 
        lines.push(`Position Accuracy: ${data.PositionAccuracy}`); 
      }
      if (data.CommunicationState !== undefined) { 
        const comm = decodeCommunicationState(data.CommunicationState);
        lines.push(`Communication State:`);
        lines.push(`- Sync State: ${comm.syncState}`);
        lines.push(`- Slot Timeout: ${comm.slotTimeout}`);
        lines.push(`- Slot Offset: ${comm.slotOffset}`);
      }
      return `<div class="popup-content">${lines.join('<br>')}</div>`;
    }

    // Adjust map bounds based on whether a vessel is focused.
    function adjustMapBounds() {
      if (focusedVessel) {
        let bounds = L.latLngBounds([]);
        bounds.extend(vesselMarkers[focusedVessel].getLatLng());
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
      } else {
        const allLatLngs = [];
        for (const key in vesselMarkers) {
          if (vesselMarkers.hasOwnProperty(key) && map.hasLayer(vesselMarkers[key])) {
            allLatLngs.push(vesselMarkers[key].getLatLng());
          }
        }
        if (allLatLngs.length > 0) {
          map.fitBounds(allLatLngs, { padding: [50, 50] });
        }
     }
   }

    document.getElementById('auto-zoom').addEventListener('change', (event) => {
      if (event.target.checked) {
        adjustMapBounds();
      }
    });

    // Utility: Compute a time elapsed string.
    function timeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return seconds + " sec ago";
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return minutes + " min ago";
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return hours + " hrs ago";
      const days = Math.floor(hours / 24);
      return days + " days ago";
    }

function updateNoCallsignMarkers() {
  const showNoCallsign = document.getElementById('filter-nocallsign').checked;
  for (const mmsi in vesselData) {
    const vesselState = vesselData[mmsi];
    const hasCallSign = (vesselState.CallSign || "").trim().length > 0;
    if (!hasCallSign && !showNoCallsign) {
      // Remove the marker and track if they exist.
      if (vesselMarkers[mmsi] && map.hasLayer(vesselMarkers[mmsi])) {
        map.removeLayer(vesselMarkers[mmsi]);
      }
      if (vesselTracks[mmsi] && map.hasLayer(vesselTracks[mmsi])) {
        map.removeLayer(vesselTracks[mmsi]);
      }
    } else {
      // Re-add the marker and track if they were removed.
      if (vesselMarkers[mmsi] && !map.hasLayer(vesselMarkers[mmsi])) {
        map.addLayer(vesselMarkers[mmsi]);
      }
      if (vesselTracks[mmsi] && !map.hasLayer(vesselTracks[mmsi])) {
        map.addLayer(vesselTracks[mmsi]);
      }
    }
  }
}

    // Update the known vessels overlay.
function updateOverlay() {
  const filterText = document.getElementById('vessel-filter').value.toLowerCase();
  const vessels = Object.values(vesselData).filter(v => 
    v.Name && v.lastUpdate &&
    (!filterText ||
      v.Name.toLowerCase().includes(filterText) ||
      (v.CallSign && v.CallSign.toLowerCase().includes(filterText)) ||
      v.UserID.toString().includes(filterText)
    )
  );
  vessels.sort((a, b) => b.lastUpdate - a.lastUpdate);
  const topVessels = vessels.slice(0, 100);
  let content = "";
  topVessels.forEach(v => {
    const name = v.Name;
    const callsign = v.CallSign ? v.CallSign : "N/A";
    const lastSeen = timeAgo(v.lastUpdate);
    // Replace the track length with the lastUpdateCount property.
    const updateCount = v.lastUpdateCount || 0;
    content += `<div class="vessel-entry" data-userid="${v.UserID}">
                  <div class="vessel-name">${name}</div>
                  <div class="vessel-callsign">Call Sign: ${callsign}</div>
                  <div class="vessel-timestamp">${lastSeen} | ${updateCount} msgs</div>
                </div>`;
  });
  document.getElementById('overlay-content').innerHTML = content;
  
  document.querySelectorAll('.vessel-entry').forEach(entry => {
    entry.addEventListener('click', (event) => {
      event.stopPropagation();
      const userID = entry.getAttribute('data-userid');
      focusOnVessel(userID);
    });
  });
}

    // Periodically update the vessel detail overlay.
    function updateVesselDetailOverlay() {
      if (!detailsOverlayHidden && focusedVessel && vesselData[focusedVessel]) {
        const popupContent = createPopupContent(vesselData[focusedVessel]);
        document.getElementById('detail-content').innerHTML = popupContent;
      }
    }
    setInterval(updateVesselDetailOverlay, 1000);
    setInterval(updateOverlay, 1000);
    // Update marker and track visibility based on the "Only Tracked" checkbox.
    function updateFocussedVisibility() {
      const onlyFocussed = document.getElementById('only-focussed').checked;
      if (onlyFocussed && focusedVessel) {
        for (const userID in vesselMarkers) {
          if (userID !== focusedVessel.toString()) {
            if (map.hasLayer(vesselMarkers[userID])) map.removeLayer(vesselMarkers[userID]);
            if (vesselTracks[userID] && map.hasLayer(vesselTracks[userID])) {
              map.removeLayer(vesselTracks[userID]);
            }
          } else {
            if (!map.hasLayer(vesselMarkers[userID])) map.addLayer(vesselMarkers[userID]);
            if (vesselTracks[userID] && !map.hasLayer(vesselTracks[userID])) {
              map.addLayer(vesselTracks[userID]);
            }
          }
        }
      } else {
        for (const userID in vesselMarkers) {
          if (!map.hasLayer(vesselMarkers[userID])) map.addLayer(vesselMarkers[userID]);
        }
        for (const userID in vesselTracks) {
          if (!map.hasLayer(vesselTracks[userID])) map.addLayer(vesselTracks[userID]);
        }
      }
    }

    // Focus on a particular vessel.
    function focusOnVessel(userID) {
      if (vesselMarkers[userID]) {
        focusedVessel = userID;
        detailsOverlayHidden = false;
        document.getElementById('vessel-detail').style.display = 'block';
        document.getElementById('toggle-detail-overlay').style.display = 'block';
        const headerEl = document.getElementById('vessel-detail-header');
        if (vesselData[userID].UserID) {
          headerEl.innerHTML = `Vessel Details (<a href="https://www.marinetraffic.com/en/ais/details/ships/mmsi:${vesselData[userID].UserID}" target="_blank">Lookup</a>)`;
        } else {
          headerEl.textContent = "Vessel Details";
        }
        const popupContent = createPopupContent(vesselData[userID]);
        document.getElementById('detail-content').innerHTML = popupContent;
        let bounds = L.latLngBounds([]);
        bounds.extend(vesselMarkers[userID].getLatLng());
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        updateFocussedVisibility();
      }
    }

    // Attach a click listener to a tooltip element.
    function attachTooltipClick(marker, userID) {
      setTimeout(() => {
        const tooltip = marker.getTooltip();
        if (tooltip) {
          const ttEl = tooltip.getElement();
          if (ttEl) {
            ttEl.addEventListener('click', (e) => {
              e.stopPropagation();
              focusOnVessel(userID);
            });
          }
        }
      }, 0);
    }

    // Toggle button for known vessels overlay.
    document.getElementById('toggle-known-overlay').addEventListener('click', () => {
      const overlay = document.getElementById('vessel-overlay');
      const btn = document.getElementById('toggle-known-overlay');
      const computedDisplay = window.getComputedStyle(overlay).display;
      if (computedDisplay === 'none') {
        overlay.style.display = 'block';
        btn.textContent = 'Hide Vessels';
      } else {
        overlay.style.display = 'none';
        btn.textContent = 'Show Vessels';
      }
    });

    // Toggle button for vessel details overlay.
    document.getElementById('toggle-detail-overlay').addEventListener('click', () => {
      const detailOverlay = document.getElementById('vessel-detail');
      const btn = document.getElementById('toggle-detail-overlay');
      if (detailOverlay.style.display === 'none' || detailOverlay.style.display === '') {
        detailOverlay.style.display = 'block';
        btn.textContent = 'Hide Details';
        detailsOverlayHidden = false;
      } else {
        detailOverlay.style.display = 'none';
        btn.textContent = 'Show Details';
        detailsOverlayHidden = true;
      }
    });

    // Load saved vessel data from localStorage if available.
    const storedData = localStorage.getItem('vesselData');
    if (storedData) {
      try {
        const parsedData = JSON.parse(storedData);
        Object.keys(parsedData).forEach(userID => {
          vesselData[userID] = parsedData[userID];
          if (
            vesselData[userID].Latitude !== undefined &&
            vesselData[userID].Longitude !== undefined
          ) {
            const lat = vesselData[userID].Latitude;
            const lon = vesselData[userID].Longitude;
            const popupContent = createPopupContent(vesselData[userID]);
            const marker = L.marker([lat, lon], { icon: boatIcon }).addTo(map);
            marker.bindPopup(popupContent, { autoPan: false });
            if (vesselData[userID].Name) {
              marker.bindTooltip(vesselData[userID].Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(marker, userID);
            }
            marker.on('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              focusOnVessel(userID);
            });
            if (!isMobile) {
              marker.on('mouseover', function() { this.openPopup(); });
              marker.on('mouseout', function() { this.closePopup(); });
            }
            vesselMarkers[userID] = marker;
          }
          if (vesselData[userID].track && vesselData[userID].track.length > 0) {
            vesselTracks[userID] = L.polyline(vesselData[userID].track, {
              color: vesselData[userID].color,
              weight: 3,
              opacity: 0.8
            }).addTo(map);
          }
        });
        adjustMapBounds();
        updateOverlay();
      } catch (e) {
        console.error("Error loading stored vessel data", e);
      }
    }

    // Listen for changes to the "Only Tracked" and "OpenSeaMap Overlay" checkboxes.
    document.getElementById('only-focussed').addEventListener('change', updateFocussedVisibility);
    document.getElementById('openseamap-overlay').addEventListener('change', () => {
      const overlayEnabled = document.getElementById('openseamap-overlay').checked;
      if (overlayEnabled) {
        if (!map.hasLayer(openSeaMapLayer)) {
          map.addLayer(openSeaMapLayer);
        }
      } else {
        if (map.hasLayer(openSeaMapLayer)) {
          map.removeLayer(openSeaMapLayer);
        }
      }
    });

    // Connect to the Socket.IO server.
    const socket = io();

    // Listen on "latest_vessel_data" which now provides a complete vessel state object.
socket.on("latest_vessel_data", (data) => {
  // console.log("Received latest vessel data:", data);  // Log the full data to verify it's correct

  // Check if the incoming data is already an object. If it's a string, we need to parse it.
  if (typeof data === "string") {
    try {
      data = JSON.parse(data);  // Parse the string into a valid object
      // console.log("Parsed vessel data:", data);  // Log parsed data to check if it's correct
    } catch (e) {
      console.error("Failed to parse JSON:", e);
      return;
    }
  }

  // Ensure the data is in the expected format (a dictionary with MMSI as keys)
  if (typeof data !== "object" || Array.isArray(data)) {
    console.error("Received invalid data format:", data);
    return;
  }

  // Step 1: Track MMSIs (vessel IDs) in new data
  const newIDs = new Set(Object.keys(data));  // Get the MMSI/UserID keys from the data object
  // console.log("New Vessel IDs:", newIDs);  // Log the MMSI IDs in the new data

  // Step 2: Remove vessels no longer present in the new data
  for (const mmsi in vesselData) {
    if (!newIDs.has(mmsi)) {  // Check if the vessel is still in the new data
      console.log("Removing vessel with MMSI:", mmsi);  // Log which vessel is being removed
      if (vesselMarkers[mmsi]) map.removeLayer(vesselMarkers[mmsi]);
      if (vesselTracks[mmsi]) map.removeLayer(vesselTracks[mmsi]);
      delete vesselData[mmsi];
      delete vesselMarkers[mmsi];
      delete vesselTracks[mmsi];
    }
  }

  // Step 3: Process each vessel in the new data
for (const mmsi in data) {
  const vesselState = data[mmsi];  // Access the vessel data using MMSI as the key
  const showNoCallsign = document.getElementById('filter-nocallsign').checked;
  const hasCallSign = (vesselState.CallSign || "").trim().length > 0;

  // If this is a new vessel, initialize the object and the counter.
  if (!vesselData[mmsi]) {
    vesselData[mmsi] = Object.assign({}, vesselState);
    vesselData[mmsi].track = [];  // Initialize an empty track (if you still need it)
    vesselData[mmsi].color = randomColor();  // Assign a random color for the track
    vesselData[mmsi].lastUpdateCount = 1;  // First update
  } else {
    // If the new LastUpdated value is different, increment the counter.
    if (vesselData[mmsi].LastUpdated !== vesselState.LastUpdated) {
      vesselData[mmsi].lastUpdateCount = (vesselData[mmsi].lastUpdateCount || 0) + 1;
    }
    Object.assign(vesselData[mmsi], vesselState);
  }
  
  // Update the stored LastUpdated value and convert it to a timestamp.
  vesselData[mmsi].LastUpdated = vesselState.LastUpdated;
  vesselData[mmsi].lastUpdate = new Date(vesselState.LastUpdated).getTime();

  // Continue with track updates as before (if needed)
  if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
    const tolerance = 1e-5;
    const track = vesselData[mmsi].track;
    const lastPoint = track[track.length - 1];
    if (!lastPoint || Math.abs(lastPoint[0] - vesselState.Latitude) > tolerance || Math.abs(lastPoint[1] - vesselState.Longitude) > tolerance) {
      track.push([vesselState.Latitude, vesselState.Longitude]);
      if (track.length > 10000) {
        track.shift();
      }
    }
  }
  // If the vessel has no callsign and the checkbox is not checked, remove its marker if it exists, then continue.
  if (!hasCallSign && !showNoCallsign) {
    if (vesselMarkers[mmsi]) {
      map.removeLayer(vesselMarkers[mmsi]);
      delete vesselMarkers[mmsi];
    }
    if (vesselTracks[mmsi]) {
      map.removeLayer(vesselTracks[mmsi]);
      delete vesselTracks[mmsi];
    }
    continue; // Skip further processing for this vessel.
  }
        const popupContent = createPopupContent(vesselData[mmsi]);
        if (typeof vesselState.Latitude === "number" && typeof vesselState.Longitude === "number") {
          const lat = vesselState.Latitude;
          const lon = vesselState.Longitude;
          if (vesselMarkers[mmsi]) {
            vesselMarkers[mmsi].setLatLng([lat, lon]);
            vesselMarkers[mmsi].getPopup().setContent(popupContent);
            if (vesselState.Name) {
              vesselMarkers[mmsi].unbindTooltip();
              vesselMarkers[mmsi].bindTooltip(vesselState.Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(vesselMarkers[mmsi], mmsi);
            }
            vesselMarkers[mmsi].off('click');
            vesselMarkers[mmsi].on('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              focusOnVessel(mmsi);
            });
            let markerElem = vesselMarkers[mmsi].getElement() || vesselMarkers[mmsi]._icon;
            if (markerElem) {
              markerElem.classList.add('enlarge');
              setTimeout(() => markerElem.classList.remove('enlarge'), 500);
            }
          } else {
            const marker = L.marker([lat, lon], { icon: boatIcon }).addTo(map);
            marker.bindPopup(popupContent, { autoPan: false });
            if (vesselState.Name) {
              marker.bindTooltip(vesselState.Name, {
                permanent: true,
                direction: 'top',
                className: 'vessel-tooltip',
                interactive: true
              }).openTooltip();
              attachTooltipClick(marker, mmsi);
            }
            marker.on('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              focusOnVessel(mmsi);
            });
            if (!isMobile) {
              marker.on('mouseover', function() { this.openPopup(); });
              marker.on('mouseout', function() { this.closePopup(); });
            }
            vesselMarkers[mmsi] = marker;
          }
          if (vesselTracks[mmsi]) {
            vesselTracks[mmsi].setLatLngs(vesselData[mmsi].track);
          } else {
            vesselTracks[mmsi] = L.polyline(vesselData[mmsi].track, {
              color: vesselData[mmsi].color,
              weight: 3,
              opacity: 0.8
            }).addTo(map);
          }
        } else {
          if (vesselMarkers[mmsi]) {
            vesselMarkers[mmsi].getPopup().setContent(popupContent);
            vesselMarkers[mmsi].unbindTooltip();
            vesselMarkers[mmsi].bindTooltip(popupContent, {
              direction: 'top',
              className: 'vessel-tooltip'
            });
          }
        }
        if (focusedVessel && focusedVessel == mmsi && !detailsOverlayHidden) {
          if (isMobile) {
            map.panTo(vesselMarkers[mmsi].getLatLng());
          } else {
            focusOnVessel(mmsi);
          }
        }
      }
      updateOverlay();
      updateFocussedVisibility();
      localStorage.setItem('vesselData', JSON.stringify(vesselData));
      if (document.getElementById('auto-zoom').checked) {
        adjustMapBounds();
      }
    });

    document.getElementById('vessel-filter').addEventListener('input', updateOverlay);

    document.getElementById('clear-history').addEventListener('click', () => {
      localStorage.removeItem('vesselData');
      Object.keys(vesselMarkers).forEach(userID => {
        map.removeLayer(vesselMarkers[userID]);
      });
      Object.keys(vesselTracks).forEach(userID => {
        map.removeLayer(vesselTracks[userID]);
      });
      Object.keys(vesselData).forEach(key => delete vesselData[key]);
      Object.keys(vesselMarkers).forEach(key => delete vesselMarkers[key]);
      Object.keys(vesselTracks).forEach(key => delete vesselTracks[key]);
      updateOverlay();
      location.reload();
    });

    document.getElementById('filter-nocallsign').addEventListener('change', () => {
      updateOverlay();
      updateFocussedVisibility();
      updateNoCallsignMarkers();
      if (document.getElementById('auto-zoom').checked) {
        adjustMapBounds();
      }
    });


    // Utility: Generate a random hex color.
    function randomColor() {
      return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
    }
  </script>
</body>
</html>
